Project Path: wbfs_file_2.9-master

Source Tree:

```txt
wbfs_file_2.9-master
├── readme.txt
└── source
    ├── Makefile
    ├── bn.c
    ├── disc_usage_table.c
    ├── ec.c
    ├── libwbfs
    │   ├── libwbfs.c
    │   ├── libwbfs.h
    │   ├── libwbfs_linux.c
    │   ├── libwbfs_os.h
    │   ├── libwbfs_osx.c
    │   ├── libwbfs_win32.c
    │   ├── wiidisc.c
    │   └── wiidisc.h
    ├── negentig.c
    ├── platform.h
    ├── scrub.c
    ├── splits.c
    ├── splits.h
    ├── tools.c
    ├── tools.h
    └── wbfs.c

```

`wbfs_file_2.9-master/readme.txt`:

```txt

wbfs_file v2.9 by oggzee
========================

Based on wbfs tool by kwiirk and wbfs_win by hermes


New functionality:
------------------
(compared to original wbfs by kwiirk)

* Conversion from .iso files to .wbfs files and vice versa.

* Handling of split .wbfs files, so that they can fit on a FAT filesystem.
  by default the split is done at 4GB - 32kb
  (32kb = 1 fat cluster and also 1 wii disc sector)

* Extraction of .wbfs files directly from a wbfs partition and back


FAQ:

Q: Can I extract all the games from a WBFS partition to .wbfs files?
A: Yes, use this command:
wbfs_file.exe W: extract_wbfs_all D:\wbfs
Where W: is your WBFS partition and D:\wbfs is the FAT partition on USB
(or any kind of filesystem on a local hard-disk)

Q: How to copy all .wbfs files back to a WBFS partition?
A: Open up CMD where your .wbfs files are and run:
for %i in (*.wbfs) do wbfs_file.exe W: add_wbfs "%i"

Q: How to convert all the .iso files to .wbfs files?
A: Open up CMD where your iso files are and run:
for %i in (*.iso) do wbfs_file.exe "%i"
Note: If you write that in a .bat batch file then
you have to use %%i instead of %i, like this:
for %%i in (*.iso) do wbfs_file.exe "%%i"

Q: How to create non-splitted .wbfs files?
A: Use -s 10000000000 option (or -0 option)
However note that files larger than 4GB cannot
be copied to a FAT filesystem partition.

Q: How to re-split the existing 2gb split files to 4gb split files?
A: Use the included resplit.bat batch file. But first it has to be
edited with proper locations for the 2 variables on top of the file:
 set WBFS_DIR=I:\wbfs
 set TEMP_DIR=D:\temp
Only the games that need to be resplit will be processed, so those
that are already a single .wbfs file will not be touched and those
that already use the 4gb-32kb split size will also not be touched.


Changes:
--------

v2.9:

 * Don't sync (write) headers on a wbfs partition when only
   reading from it to prevent any possibility of corruption.

v2.8:

 * More filename layout options:
     -l X     :  Layout of the destination filename:
                -l f0 = file: ID.ext             (same as -b)
                -l f1 = file: ID_TITLE.ext
                -l f2 = file: TITLE [ID].ext
                -l d0 = dir:  ID/ID.ext
                -l d1 = dir:  ID_TITLE/ID.ext    (same as -d)
                -l d2 = dir:  TITLE [ID]/ID.ext  [default]
   Note that not all layouts are supported by current loaders.
   Currently supported layouts in cfg loader:
   -l f0 : cfg loader v46+
   -l d1 : cfg loader v49+
   -l d2 : cfg loader v51+
   Layout -l d2 (TITLE [ID]/ID.ext) is now the default for both .iso and
   .wbfs file creation

 * Command id_title also accepts -l f0 .. f2 (but default is still ID_TITLE)

 * The ID_TITLE.txt info file creation is now disabled by default
   can be enabled with -x 1

 * More info in progress display:
   49.67% (-) ETA: 0:00:54 (2226.25MB of 4482.25MB ~ 41.82MB/s) time: 53.23s

 * Included more utility scripts:
    rename_folders-title [id].vbs
    rename_folders.vbs
    rename_titles_id.sh
    rename_titles.sh

v2.7:

 * Linux and MacOSX changes

v2.7-beta:

 * New command: wbfs_copy will copy a game directly from one wbfs
   partition to the other
 * New command: iso_info will print out some info about a wii disc
 * All commands that expect a ISO as source now also accept a device
   so that a DVD drive can be used directly
 * Commands writing to WBFS partition or file can now be aborted
   by sending ABORT<enter> to standard input

v2.6:

 * Fixed add_wbfs command for copying .wbfs files to WBFS partitions.
   (Problem was with WBFS partitions larger than 128GB,
	because of the different wbfs block sizes)

 * Command init now requires -f option to force formatting

 * Don't print sparse errors when writing .iso to FAT

v2.5:

 * Properly mark last scrubbed block as sparse when creating an .iso
   either by scrubbing or by converting from .wbfs (windows-only issue)
   (The file is the same but will use a little less space)

v2.4:

 * New option:
    -z       :  make zero filled used blocks as sparse when scrubbing
    (by default only unused (scrubbed) data is sparse)
 * Using the option -1 (copy 1:1) and the scrub command makes it a simple copy.
   Using scrub with -1 and -z makes it a generic sparse copy operation

v2.3:

 * Fixed scrub with -t option to properly pre-allocate trimmed size
   and enable sparse file mode.

v2.3-beta:

 * New command: scrub
   Will scrub the source .iso and write the destination .iso as a sparse file.
   Options that affect the created file: -u -t -d -b -g -a
   usage: wbfs_file.exe <filename.iso> scrub <DST:dir or file.iso>

 * New options:
    -u SIZE  :  Set scrub block size [32768] (1 wii sector)
                Must be a multiple of 32768 (wii sector size)
                Special values: 1=1 wii sector, 2=2mb (.wbfs block)

    -x 0|1   :  disable|enable .txt file creation

 * Included some fixes from wwt (by wiimm) for correct sector based scrubbing

 * Changed most of the options that previously accepted a destination directory
   to optionally accept a destination filename to avoid automatic file naming:

        <filename.iso>   convert  <DST:dir or file.wbfs>
        <filename.wbfs>  convert  <DST:dir or file.iso>
        <drive or file>  extract_iso      <GAMEID> <DST:dir or file.iso>
        <drive or file>  extract_wbfs     <GAMEID> <DST:dir or file.wbfs>

 * Naming of the destination .iso file when converting from .wbfs to .iso file 
   can now also be controlled using -b or -d options.
   (If none are specified the old naming is used: id_title.iso)

v2.2:
 * Fixed creation of directoris in case the title contained trailing space.
   Trailing space in directory is not allowed on windows so now it is trimmed.
 * Minor fixes to move_dirs.bat to better handle directories with spaces.
   (It still doesn't handle properly directories with exclamation marks '!')

v2.1:
 * Fixed file preallocation on windows.
   v2.0 caused the created files to contain additional blank padding
   and so was reported as inconsistent (hd num sector doesn't match)
   any .wbfs files created with v2.0 can be fixed by using:
   mkdir temp
   wbfs_file -f source.wbfs extract_wbfs_all temp
   then in temp should be the fixed file. (hopefully)

v2.0:
 * Prevent output file fragmentation by doing
   file preallocation for both .wbfs and .iso files.
 * id_title will accept an .iso or a .wbfs file
   and will no longer print the split file names, just the ID_TITLE string
 * Create GAMEID_TITLE subdirectories by default
   (this was previously enabled with -d option)
   To revert to previous behaviour use -b option:
 * new option
    -b       :  Use base directory for created .wbfs files
 * Included updated versions of a few utility scripts in
   the scripts directory:
        move_dirs.bat
        move_dirs.sh
        resplit.bat

v1.9:
 * new options:
    -d       :  Create a GAMEID_TITLE directory and place
                the created .wbfs file there
    -0       :  Don't split (split size: 10000000000)
 * new command: id_title
   will print the GAMEID_TITLE string suitable for the directory name
   (special characters :/\<>'"*? are replaced with _ space is kept)
 * included move_dirs.bat which will move *.wbfs files (and *.txt)
   to GAMEID_TITLE subdirectories

v1.8:
 * Included resplit.bat in the package
 * If the -s size is not 32kb aligned print only a warning instead of error.
   (It still has to be sector aligned or it will print an error)
 * Changed error message when reading inconsistent .wbfs files or partitions
   from:
        ERROR: reading 524288 [32768] from wbfs
        Probably corrupted. Use -f to force
   to:
        ERROR: reading 524288 [32768] from wbfs
        Possibly corrupted. Use -g to copy only game partition
   Unless -g is already specified in which case the original message is
   displayed. This is so that if only the update partition is corrupted
   one can still safely copy the game partition without risking corruption.

v1.7:
 * Changed extract_file filename to be non-case-sensitive
   and take an optional output file parameter:
   <drive or file>  extract_file  <GAMEID> <file> [<DST:file>]   
 * exit code from the program should now properly indicate an error

v1.6:
 * Changed default split size from 2gb-512b to 4gb-32kb
 * New option: -2 : use split size 2gb-32kb
 * New option: -4 : use split size 4gb-32kb (default)
 * Issue a warning if specified -s split size is not 32kb aligned.
 * Using option -f now allows to force wbfs extraction if the source
   wbfs is corrupted or has missing data - warning is printed and the
   block will be filled with 0.

v1.5:
 * Added more characters to the invalid path list: |<>
   Which are replaced with _. Full list: /\:|<>?*"' (tnx dekani)
 * Enabled debug_info command
 * Documented -f option
    -f       :  Force wbfs mode even if the wbfs file or partition
                integrity check is invalid (non matching number of
                sectors or other parameters)
 * Added option -t : trim extracted iso size
   (not recommended, is there any use for that?)

v1.4:
 * fixed -1 option for 1:1 copy.
   Note, a 1:1 copy will still scrub the last 256kb, because the wbfs
   block size (2 mb) is not aligned to the wii disc size (4699979776 b)
   However everything else is copied as is without scrubbing.
 * Replace also ? and * with _ when making a filename from title
 * make_info will create the .txt file in the same directory as the
   source .wbfs file unless the argument is a device, then the .txt
   files are created in the current dir.
 * Indicate in the help message which parameters are source (SRC:)
   and which are destination (DST:) in the first column, the parameter
   is a source unless DST: specified 
 * Added command: 'convert' which is the same as running the tool with
   just a filename, but it accepts a destination directory. Example:
     wbfs_file c:\wii\game.iso convert e:\wbfs
   will conver to e:\wbfs\GAMEID.wbfs
   While the single file parameter variant:
     wbfs_file c:\wii\game.iso
   will convert to c:\wii\GAMEID.wbfs

v1.3:
 * Fixed extracted iso size on Windows
 * Fixed ETA info for iso extraction

v1.2:
 * On Windows allow to use device name instead of drive letter in the format:
   \\?\GLOBALROOT\Device\Harddisk3\Partition2
   This is useful if you don't have a drive letter assigned to a partition

v1.1:
 * Added options:
    -a       :  Copy ALL partitions from ISO [default]
    -g       :  Copy only game partition from ISO
    -1       :  Copy 1:1 from ISO
   (Note: it's recommended to just use the defaults)

v1.0:
 * renamed commands for better clarity
   example: extractwbfsall to extract_wbfs_all ...

 * create GAMEID_TITLE.txt info files along GAMEID.wbfs files, so
   that it's easier to manage the .wbfs files

 * added command: make_info which only creates the GAMEID_TITLE.txt for
   all games on a wbfs partition or in a wbfs file

v0.9:
 * initial wbfs_file release with split file support


Usage help text as printed by wbfs_file -h :
--------------------------------------------

wbfs_file.exe 2.9 by oggzee, based on wbfs by kwiirk

Usage: wbfs_file.exe [OPTIONS] <DRIVE or FILENAME> [COMMAND [ARGS]]:

  Given just a filename it will convert from iso to wbfs or vice versa:

    wbfs_file.exe filename.iso
    Will convert filename.iso to GAMEID.wbfs
    And create an info file GAMEID_TITLE.txt

    wbfs_file.exe filename.wbfs
    Will convert filename.wbfs to GAMEID_TITLE.iso

  COMMANDS:
    <drive or file.iso>  convert  <DST:dir or file.wbfs>
        <filename.wbfs>  convert  <DST:dir or file.iso>
    <drive or file.iso>  scrub    <DST:dir or file.iso>
    <DST:filename.wbfs>  create   <SRC:drive or file.iso>
        <drive or file>  ls               
        <drive or file>  df               
        <drive or file>  make_info        
        <drive or file>  id_title         
    <DST:drive or file>  init             
    <DST:drive or file>  add_iso          <SRC:drive or file.iso>
    <DST:drive or file>  add_wbfs         <SRC:filename.wbfs>
    <DST:drive or file>  rm               <GAMEID>
        <drive or file>  extract_iso      <GAMEID> <DST:dir or file.iso>
        <drive or file>  extract_wbfs     <GAMEID> <DST:dir or file.wbfs>
        <drive or file>  extract_wbfs_all <DST:dir>
        <drive or file>  wbfs_copy        <GAMEID> <DST:drive or file.wbfs>
        <drive or file>  ls_file          <GAMEID>
        <drive or file>  extract_file     <GAMEID> <file> [<DST:file>]
        <drive or file>  debug_info       
        <drive or file>  iso_info

  OPTIONS: (it's recommended to just use the defaults)
    -s SIZE  :  Set split size [4294934528] (8388544 sectors)
                Must be a multiple of 512 (sector size)
    -2       :  Use split size: 2GB-32kb (2147450880)
    -4       :  Use split size: 4GB-32kb (4294934528)
    -0       :  Don't split (split size: 10000000000)
    -u SIZE  :  Set scrub block size [32768] (1 wii sector)
                Must be a multiple of 32768 (wii sector size)
                Special values: 1=1 wii sector, 2=2mb (.wbfs block)
    -z       :  make zero filled blocks as sparse when scrubbing
    -a       :  Copy ALL partitions from ISO [default]
    -g       :  Copy only game partition from ISO
    -1       :  Copy 1:1 from ISO
    -f       :  Force wbfs mode even if the wbfs file or partition
                integrity check is invalid (non matching number of
                sectors or other parameters)
    -t       :  trim extracted iso size
    -x 0|1   :  disable|enable .txt file creation [default:0]
    -l X     :  Layout of the destination filename:
                -l f0 = file: ID.ext             (same as -b)
                -l f1 = file: ID_TITLE.ext
                -l f2 = file: TITLE [ID].ext
                -l d0 = dir:  ID/ID.ext
                -l d1 = dir:  ID_TITLE/ID.ext    (same as -d)
                -l d2 = dir:  TITLE [ID]/ID.ext  [default]
    -b       :  Same as -l f0
    -d       :  Same as -l d1
    -h       :  Help


```

`wbfs_file_2.9-master/source/Makefile`:

```
PROGS = negentig scrub wbfs 
#COMMON = tools.o bn.o ec.o disc_usage_table.o libwbfs.o wiidisc.o rijndael.o splits.o
COMMON = tools.o bn.o ec.o libwbfs.o wiidisc.o rijndael.o splits.o
DEFINES = -DLARGE_FILES -D_FILE_OFFSET_BITS=64

CC = gcc
LIBS = -lcrypto 

ifdef CYGWIN
MSYSTEM = MINGW32
CC = /c/MinGW/bin/gcc
endif

ifeq ($(MSYSTEM),MINGW32)

	# http://sourceforge.net/projects/mingw/files/
	LIBS = -lcrypto -lwsock32 -lm
	ADD_CF = -I/mingw/include
	ADD_LF = -static
	COMMON += libwbfs_win32.o 

else ifeq ($(shell uname),Darwin)

	COMMON += libwbfs_osx.o 
	LIBS = -lcrypto -ldl -lm
	ADD_CF = -arch i386 -arch ppc
	ADD_LF = -arch i386 -arch ppc

else
	COMMON += libwbfs_linux.o 
	ADD_LF = -static
	LIBS = -lcrypto -ldl -lm
endif

#CFLAGS = -Wall -W -Os -Ilibwbfs -I.
#CFLAGS = -Wall -W  -g -ggdb $(ADD_CF) -Ilibwbfs -I.
CFLAGS = -Wall -W -O $(ADD_CF) -Ilibwbfs -I.
#LDFLAGS = -m32 -static
LDFLAGS = $(ADD_LF) 

VPATH+=libwbfs
OBJS = $(patsubst %,%.o,$(PROGS)) $(COMMON)

wbfs_file: wbfs.o $(COMMON) Makefile
	$(CC) $(CFLAGS) $(LDFLAGS) $< $(COMMON) $(LIBS) -o $@

all: $(PROGS)

$(PROGS): %: %.o $(COMMON) Makefile
	$(CC) $(CFLAGS) $(LDFLAGS) $< $(COMMON) $(LIBS) -o $@

# $(OBJS): %.o: %.c tools.h Makefile
$(OBJS): %.o: %.c tools.h
	$(CC) $(CFLAGS) $(DEFINES) -c $< -o $@ 

clean:
	-rm -f $(OBJS) $(PROGS)

```

`wbfs_file_2.9-master/source/bn.c`:

```c
// Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include <string.h>
#include <stdio.h>

#include "tools.h"

static void bn_print(char *name, u8 *a, u32 n)
{
	u32 i;

	printf("%s = ", name);

	for (i = 0; i < n; i++)
		printf("%02x", a[i]);

	printf("\n");
}

static void bn_zero(u8 *d, u32 n)
{
	memset(d, 0, n);
}

static void bn_copy(u8 *d, u8 *a, u32 n)
{
	memcpy(d, a, n);
}

int bn_compare(u8 *a, u8 *b, u32 n)
{
	u32 i;

	for (i = 0; i < n; i++) {
		if (a[i] < b[i])
			return -1;
		if (a[i] > b[i])
			return 1;
	}

	return 0;
}

void bn_sub_modulus(u8 *a, u8 *N, u32 n)
{
	u32 i;
	u32 dig;
	u8 c;

	c = 0;
	for (i = n - 1; i < n; i--) {
		dig = N[i] + c;
		c = (a[i] < dig);
		a[i] -= dig;
	}
}

void bn_add(u8 *d, u8 *a, u8 *b, u8 *N, u32 n)
{
	u32 i;
	u32 dig;
	u8 c;

	c = 0;
	for (i = n - 1; i < n; i--) {
		dig = a[i] + b[i] + c;
		c = (dig >= 0x100);
		d[i] = dig;
	}

	if (c)
		bn_sub_modulus(d, N, n);

	if (bn_compare(d, N, n) >= 0)
		bn_sub_modulus(d, N, n);
}

void bn_mul(u8 *d, u8 *a, u8 *b, u8 *N, u32 n)
{
	u32 i;
	u8 mask;

	bn_zero(d, n);

	for (i = 0; i < n; i++)
		for (mask = 0x80; mask != 0; mask >>= 1) {
			bn_add(d, d, d, N, n);
			if ((a[i] & mask) != 0)
				bn_add(d, d, b, N, n);
		}
}

void bn_exp(u8 *d, u8 *a, u8 *N, u32 n, u8 *e, u32 en)
{
	u8 t[512];
	u32 i;
	u8 mask;

	bn_zero(d, n);
	d[n-1] = 1;
	for (i = 0; i < en; i++)
		for (mask = 0x80; mask != 0; mask >>= 1) {
			bn_mul(t, d, d, N, n);
			if ((e[i] & mask) != 0)
				bn_mul(d, t, a, N, n);
			else
				bn_copy(d, t, n);
		}
}

// only for prime N -- stupid but lazy, see if I care
void bn_inv(u8 *d, u8 *a, u8 *N, u32 n)
{
	u8 t[512], s[512];

	bn_copy(t, N, n);
	bn_zero(s, n);
	s[n-1] = 2;
	bn_sub_modulus(t, s, n);
	bn_exp(d, a, N, n, t, n);
}

```

`wbfs_file_2.9-master/source/disc_usage_table.c`:

```c
// Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "tools.h"
#include "platform.h"

static FILE *disc_fp;

static u64 disc_raw_offset=0;
static u64 partition_raw_offset;
static u64 partition_data_offset;
static u64 partition_data_size;
static u64 partition_block;
static u8 h3[0x18000];

static u8 *used;

u8 disc_key[16];
int dont_decrypt = 0;

static void seek(u64 offset)
{
	if (fseeko(disc_fp, disc_raw_offset+offset, SEEK_SET))
		fatal("error seeking in disc file");
}

static void disc_read(u64 offset, u8 *data, u32 len)
{
        u32 blockno = offset>>15;
        used[blockno]=1;
	seek(offset);
	if (fread(data, len, 1, disc_fp) != 1)
		fatal("error reading disc");
}

static void partition_raw_read(u64 offset, u8 *data, u32 len)
{
	disc_read(partition_raw_offset + offset, data, len);
}

static void partition_read_block(u64 blockno, u8 *block)
{
	u8 raw[0x8000];
	u8 iv[16];
	u64 offset;
        used[partition_block+blockno]=1;
        offset = partition_data_offset + 0x8000 * blockno;
        partition_raw_read(offset, raw, 0x8000);

        // decrypt data
        memcpy(iv, raw + 0x3d0, 16);
        aes_cbc_dec(disc_key, iv, raw + 0x400, 0x7c00, block);
}

static void partition_read(u64 offset, u8 *data, u32 len,int fake)
{
	u8 block[0x8000];
	u32 offset_in_block;
	u32 len_in_block;

	while(len) {
		offset_in_block = offset % 0x7c00;
		len_in_block = 0x7c00 - offset_in_block;
		if (len_in_block > len)
			len_in_block = len;
                if(!fake){
                        partition_read_block(offset / 0x7c00, block);
                        memcpy(data, block + offset_in_block, len_in_block);
                }else
                        used[partition_block+(offset/0x7c00)]=1;
		data += len_in_block;
		offset += len_in_block;
		len -= len_in_block;
	}
}


static void copy_file(u64 offset, u64 size)
{
	u8 data[0x80000];
	u32 block_size;


	while (size) {
		block_size = sizeof data;
		if (block_size > size)
			block_size = size;

		partition_read(offset, data, block_size,1);

		offset += block_size;
		size -= block_size;
	}

}


static u32 do_fst(u8 *fst, const char *names, u32 i, char *indent, int is_last)
{
	u64 offset;
	u32 size;
	const char *name;
	u32 parent;
	u32 j;

	name = names + (be32(fst + 12*i) & 0x00ffffff);
	size = be32(fst + 12*i + 8);

	if (i == 0) {
		for (j = 1; j < size; )
			j = do_fst(fst, names, j, indent, (j == size - 1));
		return size;
	}

	if (fst[12*i]) {
		parent = be32(fst + 12*i + 4);
		is_last = (be32(fst + 12*parent + 8) == size);
	}


	if (fst[12*i]) {

		for (j = i + 1; j < size; )
			j = do_fst(fst, names, j, indent, (j == size - 1));

		indent[strlen(indent) - 4] = 0;
		return size;
	} else {
		offset = be34(fst + 12*i + 4);
		copy_file(offset, size);
		return i + 1;
	}
}

static void do_files(void)
{
	u8 b[0x480]; // XXX: determine actual header size
	u64 dol_offset;
	u64 fst_offset;
	u32 fst_size;
	u64 apl_offset;
	u32 apl_size;
	u8 apl_header[0x20];
	u8 *fst;
	char indent[999];
	u32 n_files;

	partition_read(0, b, sizeof b,0);

	dol_offset = be34(b + 0x0420);
	fst_offset = be34(b + 0x0424);
	fst_size = be34(b + 0x0428);

	apl_offset = 0x2440;
	partition_read(apl_offset, apl_header, sizeof apl_header,0);
	apl_size = 0x20 + be32(apl_header + 0x14) + be32(apl_header + 0x18);
	copy_file(apl_offset, apl_size);
	copy_file(dol_offset, fst_offset - dol_offset);
		// XXX: read the header for getting the size

	fst = malloc(fst_size);
	if (fst == 0)
		fatal("malloc fst");
	partition_read(fst_offset, fst, fst_size,0);
	n_files = be32(fst + 8);

	indent[0] = 0;
	if (n_files > 1)
		do_fst(fst, (char *)fst + 12*n_files, 0, indent, 0);

	free(fst);
}

static void do_partition(void)
{
	u8 tik[0x2a4];
	u8 b[0x1c];
	u64 title_id;
	u64 tmd_offset;
	u32 tmd_size;
	u8 *tmd;
	u64 cert_offset;
	u32 cert_size;
	u8 *cert;
	u64 h3_offset;

	// read ticket, and read some offsets and sizes
	partition_raw_read(0, tik, sizeof tik);
	partition_raw_read(0x2a4, b, sizeof b);

	tmd_size = be32(b);
	tmd_offset = be34(b + 4);
	cert_size = be32(b + 8);
	cert_offset = be34(b + 0x0c);
	h3_offset = be34(b + 0x10);
	partition_data_offset = be34(b + 0x14);
	partition_data_size = be34(b + 0x18);
        partition_block = (partition_raw_offset+partition_data_offset)>>15;
	title_id = be64(tik + 0x01dc);
	tmd = malloc(tmd_size);
	if (tmd == 0)
		fatal("malloc tmd");
	partition_raw_read(tmd_offset, tmd, tmd_size);

	cert = malloc(cert_size);
	if (cert == 0)
		fatal("malloc cert");
	partition_raw_read(cert_offset, cert, cert_size);


	decrypt_title_key(tik, disc_key);

	partition_raw_read(h3_offset, h3, 0x18000);

	free(cert);
	free(tmd);

	do_files();

}

static void do_disc(void)
{
	u8 b[0x100];
	u64 partition_offset[32]; // XXX: don't know the real maximum
	u64 partition_type[32]; // XXX: don't know the real maximum
	u32 n_partitions;
        u32 magic;
	u32 i;

	disc_read(0, b, sizeof b);
        magic=be32(b+24);
        if(magic!=0x5D1C9EA3)
                return ;
	//fprintf(stderr, "Name: %s\t\t", b + 0x20);
        //fflush(stderr);
        
	disc_read(0x40000, b, sizeof b);
	n_partitions = be32(b);

	disc_read(be34(b + 4), b, sizeof b);
	for (i = 0; i < n_partitions; i++){
		partition_offset[i] = be34(b + 8 * i);
		partition_type[i] = be32(b + 8 * i+4);
        }
	for (i = 0; i < n_partitions; i++) {
                partition_raw_offset = partition_offset[i];
                if(partition_type[i]!=1)//dont copy update partition
                {
                        do_partition();
                }
                else partition_read(0, 0, 0x8000,1);// fake read partition header, just in case it is needed

		//break; // XXX SII: for testing
	}
}
int build_disc_usage_table(FILE* fp,u8*table, u64 offset)
{
        disc_fp = fp;
        used = table;
        disc_raw_offset = offset;
        memset(used,0,143432);
        do_disc();
        return 0;
}

```

`wbfs_file_2.9-master/source/ec.c`:

```c
// Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include <string.h>
#include <stdio.h>

#include "tools.h"

// y**2 + x*y = x**3 + x + b
static u8 ec_b[30] =
	"\x00\x66\x64\x7e\xde\x6c\x33\x2c\x7f\x8c\x09\x23\xbb\x58\x21"
	"\x3b\x33\x3b\x20\xe9\xce\x42\x81\xfe\x11\x5f\x7d\x8f\x90\xad";

// order of the addition group of points
static u8 ec_N[30] =
	"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x13\xe9\x74\xe7\x2f\x8a\x69\x22\x03\x1d\x26\x03\xcf\xe0\xd7";

// base point
static u8 ec_G[60] =
	"\x00\xfa\xc9\xdf\xcb\xac\x83\x13\xbb\x21\x39\xf1\xbb\x75\x5f"
	"\xef\x65\xbc\x39\x1f\x8b\x36\xf8\xf8\xeb\x73\x71\xfd\x55\x8b"
	"\x01\x00\x6a\x08\xa4\x19\x03\x35\x06\x78\xe5\x85\x28\xbe\xbf"
	"\x8a\x0b\xef\xf8\x67\xa7\xca\x36\x71\x6f\x7e\x01\xf8\x10\x52";

static void elt_print(char *name, u8 *a)
{
	u32 i;

	printf("%s = ", name);

	for (i = 0; i < 30; i++)
		printf("%02x", a[i]);

	printf("\n");
}

static void elt_copy(u8 *d, u8 *a)
{
	memcpy(d, a, 30);
}

static void elt_zero(u8 *d)
{
	memset(d, 0, 30);
}

static int elt_is_zero(u8 *d)
{
	u32 i;

	for (i = 0; i < 30; i++)
		if (d[i] != 0)
			return 0;

	return 1;
}

static void elt_add(u8 *d, u8 *a, u8 *b)
{
	u32 i;

	for (i = 0; i < 30; i++)
		d[i] = a[i] ^ b[i];
}

static void elt_mul_x(u8 *d, u8 *a)
{
	u8 carry, x, y;
	u32 i;

	carry = a[0] & 1;

	x = 0;
	for (i = 0; i < 29; i++) {
		y = a[i + 1];
		d[i] = x ^ (y >> 7);
		x = y << 1;
	}
	d[29] = x ^ carry;

	d[20] ^= carry << 2;
}

static void elt_mul(u8 *d, u8 *a, u8 *b)
{
	u32 i, n;
	u8 mask;

	elt_zero(d);

	i = 0;
	mask = 1;
	for (n = 0; n < 233; n++) {
		elt_mul_x(d, d);

		if ((a[i] & mask) != 0)
			elt_add(d, d, b);

		mask >>= 1;
		if (mask == 0) {
			mask = 0x80;
			i++;
		}
	}
}

static const u8 square[16] =
	"\x00\x01\x04\x05\x10\x11\x14\x15\x40\x41\x44\x45\x50\x51\x54\x55";

static void elt_square_to_wide(u8 *d, u8 *a)
{
	u32 i;

	for (i = 0; i < 30; i++) {
		d[2*i] = square[a[i] >> 4];
		d[2*i + 1] = square[a[i] & 15];
	}
}

static void wide_reduce(u8 *d)
{
	u32 i;
	u8 x;

	for (i = 0; i < 30; i++) {
		x = d[i];

		d[i + 19] ^= x >> 7;
		d[i + 20] ^= x << 1;

		d[i + 29] ^= x >> 1;
		d[i + 30] ^= x << 7;
	}

	x = d[30] & ~1;

	d[49] ^= x >> 7;
	d[50] ^= x << 1;

	d[59] ^= x >> 1;

	d[30] &= 1;
}

static void elt_square(u8 *d, u8 *a)
{
	u8 wide[60];

	elt_square_to_wide(wide, a);
	wide_reduce(wide);

	elt_copy(d, wide + 30);
}

static void itoh_tsujii(u8 *d, u8 *a, u8 *b, u32 j)
{
	u8 t[30];

	elt_copy(t, a);
	while (j--) {
		elt_square(d, t);
		elt_copy(t, d);
	}

	elt_mul(d, t, b);
}

static void elt_inv(u8 *d, u8 *a)
{
	u8 t[30];
	u8 s[30];

	itoh_tsujii(t, a, a, 1);
	itoh_tsujii(s, t, a, 1);
	itoh_tsujii(t, s, s, 3);
	itoh_tsujii(s, t, a, 1);
	itoh_tsujii(t, s, s, 7);
	itoh_tsujii(s, t, t, 14);
	itoh_tsujii(t, s, a, 1);
	itoh_tsujii(s, t, t, 29);
	itoh_tsujii(t, s, s, 58);
	itoh_tsujii(s, t, t, 116);
	elt_square(d, s);
}

static int point_is_on_curve(u8 *p)
{
	u8 s[30], t[30];
	u8 *x, *y;

	x = p;
	y = p + 30;

	elt_square(t, x);
	elt_mul(s, t, x);

	elt_add(s, s, t);

	elt_square(t, y);
	elt_add(s, s, t);

	elt_mul(t, x, y);
	elt_add(s, s, t);

	elt_add(s, s, ec_b);

	return elt_is_zero(s);
}

static int point_is_zero(u8 *p)
{
	return elt_is_zero(p) && elt_is_zero(p + 30);
}

static void point_double(u8 *r, u8 *p)
{
	u8 s[30], t[30];
	u8 *px, *py, *rx, *ry;

	px = p;
	py = p + 30;
	rx = r;
	ry = r + 30;

	if (elt_is_zero(px)) {
		elt_zero(rx);
		elt_zero(ry);

		return;
	}

	elt_inv(t, px);
	elt_mul(s, py, t);
	elt_add(s, s, px);

	elt_square(t, px);

	elt_square(rx, s);
	elt_add(rx, rx, s);
	rx[29] ^= 1;

	elt_mul(ry, s, rx);
	elt_add(ry, ry, rx);
	elt_add(ry, ry, t);
}

static void point_add(u8 *r, u8 *p, u8 *q)
{
	u8 s[30], t[30], u[30];
	u8 *px, *py, *qx, *qy, *rx, *ry;

	px = p;
	py = p + 30;
	qx = q;
	qy = q + 30;
	rx = r;
	ry = r + 30;

	if (point_is_zero(p)) {
		elt_copy(rx, qx);
		elt_copy(ry, qy);
		return;
	}

	if (point_is_zero(q)) {
		elt_copy(rx, px);
		elt_copy(ry, py);
		return;
	}

	elt_add(u, px, qx);

	if (elt_is_zero(u)) {
		elt_add(u, py, qy);
		if (elt_is_zero(u))
			point_double(r, p);
		else {
			elt_zero(rx);
			elt_zero(ry);
		}

		return;
	}

	elt_inv(t, u);
	elt_add(u, py, qy);
	elt_mul(s, t, u);

	elt_square(t, s);
	elt_add(t, t, s);
	elt_add(t, t, qx);
	t[29] ^= 1;

	elt_mul(u, s, t);
	elt_add(s, u, py);
	elt_add(rx, t, px);
	elt_add(ry, s, rx);
}

static void point_mul(u8 *d, u8 *a, u8 *b)	// a is bignum
{
	u32 i;
	u8 mask;

	elt_zero(d);
	elt_zero(d + 30);

	for (i = 0; i < 30; i++)
		for (mask = 0x80; mask != 0; mask >>= 1) {
			point_double(d, d);
			if ((a[i] & mask) != 0)
				point_add(d, d, b);
		}
}

void generate_ecdsa(u8 *R, u8 *S, u8 *k, u8 *hash)
{
	u8 e[30];
	u8 kk[30];

	elt_zero(e);
	memcpy(e + 10, hash, 20);

	// should take random m --> but we take 1
	//	R = (mG).x
	//	S = m**-1*(e + Rk) (mod N)
	// so, we get:
	//	R = G.x
	//	S = e + Rk (mod N)

	elt_copy(R, ec_G);
	if (bn_compare(R, ec_N, 30) >= 0)
		bn_sub_modulus(R, ec_N, 30);
	elt_copy(kk, k);
	if (bn_compare(kk, ec_N, 30) >= 0)
		bn_sub_modulus(kk, ec_N, 30);
	bn_mul(S, R, kk, ec_N, 30);
	bn_add(S, S, e, ec_N, 30);
}

int check_ecdsa(u8 *Q, u8 *R, u8 *S, u8 *hash)
{
	u8 Sinv[30];
	u8 e[30];
	u8 w1[30], w2[30];
	u8 r1[60], r2[60];

	bn_inv(Sinv, S, ec_N, 30);

	elt_zero(e);
	memcpy(e + 10, hash, 20);

	bn_mul(w1, e, Sinv, ec_N, 30);
	bn_mul(w2, R, Sinv, ec_N, 30);

	point_mul(r1, w1, ec_G);
	point_mul(r2, w2, Q);

	point_add(r1, r1, r2);

	if (bn_compare(r1, ec_N, 30) >= 0)
		bn_sub_modulus(r1, ec_N, 30);

	return (bn_compare(r1, R, 30) == 0);
}

void ec_priv_to_pub(u8 *k, u8 *Q)
{
	point_mul(Q, k, ec_G);
}

```

`wbfs_file_2.9-master/source/libwbfs/libwbfs.c`:

```c
// Copyright 2009 Kwiirk
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt


#include "libwbfs.h"

extern double spinner_bs;

#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)

#ifdef ERROR
#undef ERROR
#endif
#define ERROR(x) do {wbfs_error(x);goto error;}while(0)
#define ALIGN_LBA(x) (((x)+p->hd_sec_sz-1)&(~(p->hd_sec_sz-1)))
static int force_mode=0;
void wbfs_set_force_mode(int force)
{
        force_mode = force;
}
static u8 size_to_shift(u32 size)
{
        u8 ret = 0;
        while(size)
        {
                ret++;
                size>>=1;
        }
        return ret-1;
}
#define read_le32_unaligned(x) ((x)[0]|((x)[1]<<8)|((x)[2]<<16)|((x)[3]<<24))

void wbfs_sync(wbfs_t*p);
int print_read_err(u32 offset, u32 count);

wbfs_t*wbfs_open_hd(rw_sector_callback_t read_hdsector,
                 rw_sector_callback_t write_hdsector,
                 void *callback_data,
                    int hd_sector_size, int num_hd_sector __attribute((unused)), int reset)
{
        int i=num_hd_sector,ret;
        u8 *ptr,*tmp_buffer = wbfs_ioalloc(hd_sector_size);
        u8 part_table[16*4];
        ret = read_hdsector(callback_data,0,1,tmp_buffer);
        if(ret)
                return 0;
        //find wbfs partition
        wbfs_memcpy(part_table,tmp_buffer+0x1be,16*4);
        ptr = part_table;
        for(i=0;i<4;i++,ptr+=16)
        {
                u32 part_lba = read_le32_unaligned(ptr+0x8);
                wbfs_head_t *head = (wbfs_head_t *)tmp_buffer;
                ret = read_hdsector(callback_data,part_lba,1,tmp_buffer);
                // verify there is the magic.
                if (head->magic == wbfs_htonl(WBFS_MAGIC))
                {
                        wbfs_t*p = wbfs_open_partition(read_hdsector,write_hdsector,
                                                callback_data,hd_sector_size,0,part_lba,reset);
                        return p;
                }
        }
        if(reset)// XXX make a empty hd partition..
        {
        }
        return 0;
}

wbfs_t*wbfs_open_partition(rw_sector_callback_t read_hdsector,
                           rw_sector_callback_t write_hdsector,
                           void *callback_data,
                           int hd_sector_size, int num_hd_sector, u32 part_lba, int reset)
{
        wbfs_t *p = wbfs_malloc(sizeof(wbfs_t));
		memset(p, 0, sizeof(wbfs_t));
        
        wbfs_head_t *head = wbfs_ioalloc(hd_sector_size?hd_sector_size:512);

        //constants, but put here for consistancy
        p->wii_sec_sz = 0x8000;
        p->wii_sec_sz_s = size_to_shift(0x8000);
        p->n_wii_sec = (num_hd_sector/0x8000)*hd_sector_size;
        p->n_wii_sec_per_disc = 143432*2;//support for double layers discs..
        p->head = head;
        p->part_lba = part_lba;
        // init the partition
        if (reset)
        {
                u8 sz_s;
                wbfs_memset(head,0,hd_sector_size);
                head->magic = wbfs_htonl(WBFS_MAGIC);
                head->hd_sec_sz_s = size_to_shift(hd_sector_size);
                head->n_hd_sec = wbfs_htonl(num_hd_sector);
                // choose minimum wblk_sz that fits this partition size
                for(sz_s=6;sz_s<11;sz_s++)
                {
                        // ensure that wbfs_sec_sz is big enough to address every blocks using 16 bits
                        if(p->n_wii_sec <((1U<<16)*(1<<sz_s)))
                                break;
                }
                head->wbfs_sec_sz_s = sz_s+p->wii_sec_sz_s;
        }else
                read_hdsector(callback_data,p->part_lba,1,head);
        if (head->magic != wbfs_htonl(WBFS_MAGIC))
                ERROR("bad magic");
        if(!force_mode && hd_sector_size && head->hd_sec_sz_s !=  size_to_shift(hd_sector_size))
                ERROR("hd sector size doesn't match");
        if(!force_mode && num_hd_sector && head->n_hd_sec != wbfs_htonl(num_hd_sector))
                ERROR("hd num sector doesn't match");
        p->hd_sec_sz = 1<<head->hd_sec_sz_s;
        p->hd_sec_sz_s = head->hd_sec_sz_s;
        p->n_hd_sec = wbfs_ntohl(head->n_hd_sec);

        p->n_wii_sec = (p->n_hd_sec/p->wii_sec_sz)*(p->hd_sec_sz);
        
        p->wbfs_sec_sz_s = head->wbfs_sec_sz_s;
        p->wbfs_sec_sz = 1<<p->wbfs_sec_sz_s;
        p->n_wbfs_sec = p->n_wii_sec >> (p->wbfs_sec_sz_s - p->wii_sec_sz_s);
        p->n_wbfs_sec_per_disc = p->n_wii_sec_per_disc >> (p->wbfs_sec_sz_s - p->wii_sec_sz_s);
        p->disc_info_sz = ALIGN_LBA(sizeof(wbfs_disc_info_t) + p->n_wbfs_sec_per_disc*2);

        //printf("hd_sector_size %X wii_sector size %X wbfs sector_size %X\n",p->hd_sec_sz,p->wii_sec_sz,p->wbfs_sec_sz);
        p->read_hdsector = read_hdsector;
        p->write_hdsector = write_hdsector;
        p->callback_data = callback_data;

        p->freeblks_lba = (p->wbfs_sec_sz - p->n_wbfs_sec/8)>>p->hd_sec_sz_s;
        
        if(!reset)
                p->freeblks = 0; // will alloc and read only if needed
        else
        {
                // init with all free blocks
                p->freeblks = wbfs_ioalloc(ALIGN_LBA(p->n_wbfs_sec/8));
                wbfs_memset(p->freeblks,0xff,p->n_wbfs_sec/8);
        }
        p->max_disc = (p->freeblks_lba-1)/(p->disc_info_sz>>p->hd_sec_sz_s);
        if(p->max_disc > p->hd_sec_sz - sizeof(wbfs_head_t))
                p->max_disc = p->hd_sec_sz - sizeof(wbfs_head_t);

        p->tmp_buffer = wbfs_ioalloc(p->hd_sec_sz);
        p->n_disc_open = 0;
		if (reset) {
	        wbfs_sync(p);
		}
        return p;
error:
        wbfs_free(p);
        wbfs_iofree(head);
        return 0;
            
}

void wbfs_sync(wbfs_t*p)
{
        // copy back descriptors
        if(p->write_hdsector){
                p->write_hdsector(p->callback_data,p->part_lba+0,1, p->head);
                
                if(p->freeblks)
                        p->write_hdsector(p->callback_data,p->part_lba+p->freeblks_lba,ALIGN_LBA(p->n_wbfs_sec/8)>>p->hd_sec_sz_s, p->freeblks);
        }
}
void wbfs_close(wbfs_t*p)
{
        //wbfs_sync(p);

        if(p->n_disc_open)
                ERROR("trying to close wbfs while discs still open");

        wbfs_iofree(p->head);
        wbfs_iofree(p->tmp_buffer);
        if(p->freeblks)
                wbfs_iofree(p->freeblks);

		if (p->close_hd)
			p->close_hd(p->callback_data);
   
        wbfs_free(p);
        
error:
        return;
}

wbfs_disc_t *wbfs_open_disc(wbfs_t* p, u8 *discid)
{
        u32 i;
        int disc_info_sz_lba = p->disc_info_sz>>p->hd_sec_sz_s;
        wbfs_disc_t *d = 0;
        for(i=0;i<p->max_disc;i++)
        {
                if (p->head->disc_table[i]){
                        p->read_hdsector(p->callback_data,
                                         p->part_lba+1+i*disc_info_sz_lba,1,p->tmp_buffer);
                        if(wbfs_memcmp(discid,p->tmp_buffer,6)==0){
                                d = wbfs_malloc(sizeof(*d));
                                if(!d)
                                        ERROR("allocating memory");
                                d->p = p;
                                d->i = i;
                                d->header = wbfs_ioalloc(p->disc_info_sz);
                                if(!d->header)
                                        ERROR("allocating memory");
                                p->read_hdsector(p->callback_data,
                                                  p->part_lba+1+i*disc_info_sz_lba,
                                                  disc_info_sz_lba,d->header);
                                p->n_disc_open ++;
//                                for(i=0;i<p->n_wbfs_sec_per_disc;i++)
//                                        printf("%d,",wbfs_ntohs(d->header->wlba_table[i]));
                                return d;
                        }
                }
        }
        return 0;
error:
        if(d)
                wbfs_iofree(d);
        return 0;
        
}
void wbfs_close_disc(wbfs_disc_t*d)
{
        d->p->n_disc_open --;
        wbfs_iofree(d->header);
        wbfs_free(d);
}
// offset is pointing 32bit words to address the whole dvd, although len is in bytes
int wbfs_disc_read(wbfs_disc_t*d,u32 offset, u8 *data, u32 len)
{
 
        wbfs_t *p = d->p;
        u16 wlba = offset>>(p->wbfs_sec_sz_s-2);
        u32 iwlba_shift = p->wbfs_sec_sz_s - p->hd_sec_sz_s;
        u32 lba_mask = (p->wbfs_sec_sz-1)>>(p->hd_sec_sz_s);
        u32 lba = (offset>>(p->hd_sec_sz_s-2))&lba_mask;
        u32 off = offset&((p->hd_sec_sz>>2)-1);
        u16 iwlba = wbfs_ntohs(d->header->wlba_table[wlba]);
        u32 len_copied;
        int err = 0;
        u8  *ptr = data;
        if(unlikely(iwlba==0))
                return 1;
        if(unlikely(off)){
                off*=4;
                err = p->read_hdsector(p->callback_data,
                                       p->part_lba + (iwlba<<iwlba_shift) + lba, 1, p->tmp_buffer);
                if(err)
                        return err;
                len_copied = p->hd_sec_sz - off;
                if(likely(len < len_copied))
                        len_copied = len;
                wbfs_memcpy(ptr, p->tmp_buffer + off, len_copied);
                len -= len_copied;
                ptr += len_copied;
                lba++;
                if(unlikely(lba>lba_mask && len)){
                        lba=0;
                        iwlba =  wbfs_ntohs(d->header->wlba_table[++wlba]);
                        if(unlikely(iwlba==0))
                                return 1;
                }
        }
        while(likely(len>=p->hd_sec_sz))
        {
                u32 nlb = len>>(p->hd_sec_sz_s);
                
                if(unlikely(lba + nlb > p->wbfs_sec_sz)) // dont cross wbfs sectors..
                        nlb = p->wbfs_sec_sz-lba;
                err = p->read_hdsector(p->callback_data,
                                 p->part_lba + (iwlba<<iwlba_shift) + lba, nlb, ptr);
                if(err)
                        return err;
                len -= nlb<<p->hd_sec_sz_s;
                ptr += nlb<<p->hd_sec_sz_s;
                lba += nlb;
                if(unlikely(lba>lba_mask && len)){
                        lba = 0;
                        iwlba =wbfs_ntohs(d->header->wlba_table[++wlba]);
                        if(unlikely(iwlba==0))
                                return 1;
                }
        }
        if(unlikely(len)){
                err = p->read_hdsector(p->callback_data,
                                 p->part_lba + (iwlba<<iwlba_shift) + lba, 1, p->tmp_buffer);
                if(err)
                        return err;
                wbfs_memcpy(ptr, p->tmp_buffer, len);
        }     
        return 0;
}

// disc listing
u32 wbfs_count_discs(wbfs_t*p)
{
        u32 i,count=0;
        for(i=0;i<p->max_disc;i++)
                if (p->head->disc_table[i])
                        count++;
        return count;
}

u32 wbfs_sector_used(wbfs_t *p,wbfs_disc_info_t *di)
{
        u32 tot_blk=0,j;
        for(j=0;j<p->n_wbfs_sec_per_disc;j++)
                if(wbfs_ntohs(di->wlba_table[j]))
                        tot_blk++;
        return tot_blk;
}

u32 wbfs_sector_used2(wbfs_t *p,wbfs_disc_info_t *di, u32 *last_blk)
{
        u32 tot_blk=0,j;
        for(j=0;j<p->n_wbfs_sec_per_disc;j++)
                if(wbfs_ntohs(di->wlba_table[j])) {
                        *last_blk = j;
                        tot_blk++;
				}
        return tot_blk;
}

u32 wbfs_get_disc_info(wbfs_t*p, u32 index,u8 *header,int header_size,u32 *size)//size in 32 bit
{
        u32 i,count=0;
        int disc_info_sz_lba = p->disc_info_sz>>p->hd_sec_sz_s;
        for(i=0;i<p->max_disc;i++)
                if (p->head->disc_table[i]){
                        if(count++==index)
                        {
                                p->read_hdsector(p->callback_data,
                                                 p->part_lba+1+i*disc_info_sz_lba,1,p->tmp_buffer);
                                if(header_size > (int)p->hd_sec_sz)
                                        header_size = p->hd_sec_sz;
                                u32 magic = wbfs_ntohl(*(u32*)(p->tmp_buffer+24));
                                if(magic!=0x5D1C9EA3){
                                        p->head->disc_table[i]=0;
                                        return 1;
                                }
                                memcpy(header,p->tmp_buffer,header_size);
                                if(size)
                                {
                                        u8 *header = wbfs_ioalloc(p->disc_info_sz);
                                        p->read_hdsector(p->callback_data,
                                                         p->part_lba+1+i*disc_info_sz_lba,disc_info_sz_lba,header);
                                        u32 sec_used = wbfs_sector_used(p,(wbfs_disc_info_t *)header);
                                        wbfs_iofree(header);
                                        *size = sec_used<<(p->wbfs_sec_sz_s-2);
                                }
                                return 0;
                        }
                }
        return 1;
}

static void load_freeblocks(wbfs_t*p)
{
        if(p->freeblks)
                return;
        // XXX should handle malloc error..
        p->freeblks = wbfs_ioalloc(ALIGN_LBA(p->n_wbfs_sec/8));
        p->read_hdsector(p->callback_data,p->part_lba+p->freeblks_lba,ALIGN_LBA(p->n_wbfs_sec/8)>>p->hd_sec_sz_s, p->freeblks);
        
}
u32 wbfs_count_usedblocks(wbfs_t*p)
{
        u32 i,j,count=0;
        load_freeblocks(p);
        for(i=0;i<p->n_wbfs_sec/(8*4);i++)
        {
                u32 v = wbfs_ntohl(p->freeblks[i]);
                if(v == ~0U)
                     count+=32;
                else if(v!=0)
                        for(j=0;j<32;j++)
                                if (v & (1<<j))
                                        count++;
        }
        return count;
}


// write access


int block_used(u8 *used,u32 i,u32 wblk_sz)
{
        u32 k;
        i*=wblk_sz;
        for(k=0;k<wblk_sz;k++)
                if(i+k<143432*2 && used[i+k])
                        return 1;
        return 0;
}

static u32 alloc_block(wbfs_t*p)
{
        u32 i,j;
        for(i=0;i<p->n_wbfs_sec/(8*4);i++)
        {
                u32 v = wbfs_ntohl(p->freeblks[i]);
                if(v != 0)
                {
                        for(j=0;j<32;j++)
                                if (v & (1<<j))
                                {
                                        p->freeblks[i] = wbfs_htonl(v & ~(1<<j));
                                        return (i*32)+j+1;
                                }
                }
        }
        return ~0;
}
static void free_block(wbfs_t *p,int bl)
{
        int i = (bl-1)/(32);
        int j = (bl-1)&31;
        u32 v = wbfs_ntohl(p->freeblks[i]);
        p->freeblks[i] = wbfs_htonl(v | 1<<j);
}

u32 wbfs_add_disc(wbfs_t*p, read_wiidisc_callback_t read_src_wii_disc,
		void *callback_data,progress_callback_t spinner,partition_selector_t sel,int copy_1_1)
{
	int i,discn;
	u32 tot,cur;
	u32 wii_sec_per_wbfs_sect = 1<<(p->wbfs_sec_sz_s-p->wii_sec_sz_s);
	wiidisc_t *d = 0;
	u8 *used = 0;
	wbfs_disc_info_t *info = 0;
	u8* copy_buffer = 0;
	int num_wbfs_sect_to_copy;
	u32 last_used;
	used = wbfs_malloc(p->n_wii_sec_per_disc);

	if(!used)
		ERROR("unable to alloc memory");
	// copy_1_1 needs disk usage for layers detection
	//if(!copy_1_1)
	{
		d = wd_open_disc(read_src_wii_disc,callback_data);
		if(!d)
			ERROR("unable to open wii disc");
		wd_build_disc_usage(d,sel,used);
		wd_close_disc(d);
		d = 0;
	}
    #if 0
    // debug: dump usage table
	for (i=0; i<(int)p->n_wii_sec_per_disc; i++) {
        if ( (i%wii_sec_per_wbfs_sect) == 0 ) {
            printf("\n%05x : ", i);
        }
	    printf("%d", block_used(used,i,1));
	}
    printf("\n");
    exit(0);
    #endif

	for(i=0;i<p->max_disc;i++)// find a free slot.
		if(p->head->disc_table[i]==0)
			break;
	if(i==p->max_disc)
		ERROR("no space left on device (table full)");
	p->head->disc_table[i] = 1;
	discn = i;
	load_freeblocks(p);

	// build disc info
	info = wbfs_ioalloc(p->disc_info_sz);
	u8*b = (u8*)info;
	read_src_wii_disc(callback_data,0,0x100,info->disc_header_copy);
	fprintf(stderr, "adding %c%c%c%c%c%c %s...\n",b[0], b[1], b[2], b[3], b[4], b[5], b + 0x20);

	copy_buffer = wbfs_ioalloc(p->wii_sec_sz);
	if(!copy_buffer)
		ERROR("alloc memory");
	tot=0;
	cur=0;
	num_wbfs_sect_to_copy = p->n_wbfs_sec_per_disc;
	// count total number of sectors to write
	last_used = 0;
	for(i=0; i<num_wbfs_sect_to_copy; i++) {
		if(block_used(used,i,wii_sec_per_wbfs_sect)) {
			tot += wii_sec_per_wbfs_sect;
			last_used = i;
		}
	}
	if (copy_1_1) {
		// detect single or dual layer
		if ( (last_used + 1) > (p->n_wbfs_sec_per_disc / 2) ) {
			// dual layer
			num_wbfs_sect_to_copy = p->n_wbfs_sec_per_disc;
		} else {
			// single layer
			num_wbfs_sect_to_copy = p->n_wbfs_sec_per_disc / 2;
		}
		tot = num_wbfs_sect_to_copy * wii_sec_per_wbfs_sect;
	}
	/*
	// num of hd sectors to copy could be specified directly
	if (copy_1_1 > 1) {
		u32 hd_sec_per_wii_sec = p->wii_sec_sz / p->hd_sec_sz;
		num_wbfs_sect_to_copy = copy_1_1 / hd_sec_per_wii_sec / wii_sec_per_wbfs_sect;
		tot = num_wbfs_sect_to_copy * wii_sec_per_wbfs_sect;
	}*/
	int ret = 0;
	if(spinner) {
		spinner_bs = p->wii_sec_sz;
		spinner(0,tot);
	}
	for(i=0; i<num_wbfs_sect_to_copy; i++){
		u16 bl = 0;
		if(copy_1_1 || block_used(used,i,wii_sec_per_wbfs_sect)) {
			u16 j;

			bl = alloc_block(p);
			if (bl==0xffff)
				ERROR("no space left on device (disc full)");
			for(j=0; j<wii_sec_per_wbfs_sect;j++) {
				u32 offset = (i*(p->wbfs_sec_sz>>2)) + (j*(p->wii_sec_sz>>2));

                int check_abort();
                if (check_abort()) {
                    // exit so that disc headers and alloc table are not written
                    printf("\nABORTED\n");
                    exit(2);
                }

				ret = read_src_wii_disc(callback_data, offset, p->wii_sec_sz, copy_buffer);
				if (ret) {
					// error reading, check if block is really neccesary
					u32 wii_sec = i * wii_sec_per_wbfs_sect + j;
					if (copy_1_1) {
						if ( (i > p->n_wbfs_sec_per_disc / 2)
								&& (i == num_wbfs_sect_to_copy-1))
						{
							// end of dual layer data
							goto zero_fill;
						}
						goto print_err;
					} else {
						if (block_used(used, wii_sec, 1)) {
							print_err:
							if (print_read_err(offset, p->wii_sec_sz) == 0) {
								// forced
								goto zero_fill;
							}
							ERROR("read error");
						} else {
							// zero fill
							zero_fill:
							memset(copy_buffer, 0, p->wii_sec_sz);
							ret = 0;
						}
					}
				}

				//fix the partition table
				if(offset == (0x40000>>2))
					wd_fix_partition_table(d, sel, copy_buffer);
				ret = p->write_hdsector(p->callback_data,
						p->part_lba+bl*(p->wbfs_sec_sz/p->hd_sec_sz) + j*(p->wii_sec_sz/p->hd_sec_sz),
						p->wii_sec_sz/p->hd_sec_sz, copy_buffer);
				if (ret) {
					ERROR("write error");
				}
				cur++;
				if(spinner)
					spinner(cur,tot);
			}
		}
		info->wlba_table[i] = wbfs_htons(bl);
	}
	// write disc info
	int disc_info_sz_lba = p->disc_info_sz>>p->hd_sec_sz_s;
	p->write_hdsector(p->callback_data,p->part_lba+1+discn*disc_info_sz_lba,disc_info_sz_lba,info);
	wbfs_sync(p);
error:
	if(d)
		wd_close_disc(d);
	if(used)
		wbfs_free(used);
	if(info)
		wbfs_iofree(info);
	if(copy_buffer)
		wbfs_iofree(copy_buffer);
	// init with all free blocks

	return 0;
}

u32 wbfs_rm_disc(wbfs_t*p, u8* discid)
{
        wbfs_disc_t *d = wbfs_open_disc(p,discid);
        int i;
        int discn = 0;
        int disc_info_sz_lba = p->disc_info_sz>>p->hd_sec_sz_s;
        if(!d)
                return 1;
        load_freeblocks(p);
        discn = d->i;
        for( i=0; i< p->n_wbfs_sec_per_disc; i++)
        {
                u32 iwlba = wbfs_ntohs(d->header->wlba_table[i]);
                if (iwlba)
                        free_block(p,iwlba);
        }
        memset(d->header,0,p->disc_info_sz);
        p->write_hdsector(p->callback_data,p->part_lba+1+discn*disc_info_sz_lba,disc_info_sz_lba,d->header);
        p->head->disc_table[discn] = 0;
        wbfs_close_disc(d);
        wbfs_sync(p);
        return 0;
}

/* trim the file-system to its minimum size
 */
u32 wbfs_trim(wbfs_t*p)
{
        u32 maxbl;
        load_freeblocks(p);
        maxbl = alloc_block(p);
        p->n_hd_sec = maxbl<<(p->wbfs_sec_sz_s-p->hd_sec_sz_s);
        p->head->n_hd_sec = wbfs_htonl(p->n_hd_sec);
        // make all block full
        memset(p->freeblks,0,p->n_wbfs_sec/8);
        wbfs_sync(p);
        // os layer will truncate the file.
        return maxbl;
}

// data extraction
u32 wbfs_extract_disc(wbfs_disc_t*d, rw_sector_callback_t write_dst_wii_sector,void *callback_data,progress_callback_t spinner)
{
        wbfs_t *p = d->p;
        u8* copy_buffer = 0;
        int i;
        u32 tot,cur; // for spinner
        int src_wbs_nlb=p->wbfs_sec_sz/p->hd_sec_sz;
        int dst_wbs_nlb=p->wbfs_sec_sz/p->wii_sec_sz;
        copy_buffer = wbfs_ioalloc(p->wbfs_sec_sz);
        if(!copy_buffer)
                ERROR("alloc memory");

        tot = cur = 0;
        if(spinner) {
            for( i=0; i< p->n_wbfs_sec_per_disc; i++)
                if (wbfs_ntohs(d->header->wlba_table[i])) tot++;
            spinner_bs = p->wbfs_sec_sz;
            spinner(0, tot);
        }
        for( i=0; i< p->n_wbfs_sec_per_disc; i++)
        {
                u32 iwlba = wbfs_ntohs(d->header->wlba_table[i]);
                if (iwlba)
                {
                        if(spinner) spinner(cur, tot); cur++;
                        p->read_hdsector(p->callback_data, p->part_lba + iwlba*src_wbs_nlb, src_wbs_nlb, copy_buffer);
                        write_dst_wii_sector(callback_data, i*dst_wbs_nlb, dst_wbs_nlb, copy_buffer);
                }
        }
        if (spinner) spinner(tot,tot);
        wbfs_iofree(copy_buffer);
        return 0;
error:
        return 1;
}

u32 wbfs_size_disc(wbfs_t*p,read_wiidisc_callback_t read_src_wii_disc,
                  void *callback_data,partition_selector_t sel,
				  u32 *comp_size, u32 *real_size)
{
        int i;
        u32 tot = 0, last = 0;
        u32 wii_sec_per_wbfs_sect = 1<<(p->wbfs_sec_sz_s-p->wii_sec_sz_s);
        wiidisc_t *d = 0;
        u8 *used = 0;
        used = wbfs_malloc(p->n_wii_sec_per_disc);
        if(!used)
                ERROR("unable to alloc memory");
		d = wd_open_disc(read_src_wii_disc,callback_data);
		if(!d)
				ERROR("unable to open wii disc");
		wd_build_disc_usage(d,sel,used);
		wd_close_disc(d);
		d = 0;

		// count total number to write for spinner
		for(i=0; i<p->n_wbfs_sec_per_disc;i++) {
			if(block_used(used,i,wii_sec_per_wbfs_sect)) {
				tot += wii_sec_per_wbfs_sect;
				last = i * wii_sec_per_wbfs_sect;
			}
		}

error:
        if(d)
                wd_close_disc(d);
        if(used)
                wbfs_free(used);

		*comp_size = tot;
		*real_size = last;
        
        return 0;
}

static int first_warn = 1;

int print_read_err(u32 offset, u32 count)
{
	if (force_mode) {
		if (first_warn) {
			printf("WARNING: error reading %d [%d] from wbfs\n", offset, count);
			printf("Probably corrupted. Using force mode (fill with 0)\n");
			first_warn = 0;
		}
		return 0;
	} else {
		if (first_warn) {
			printf("ERROR: reading %d [%d] from wbfs\n", offset, count);
			extern int OPT_part_all;
			if (OPT_part_all) {
				printf("Possibly corrupted. Use -g to copy only game partition\n");
			} else {
				printf("Probably corrupted. Use -f to force\n");
			}
			first_warn = 0;
		}
	}
	return -1;
}

// offset is pointing 32bit words to address the whole dvd, although len is in bytes
//int wbfs_disc_read(wbfs_disc_t*d,u32 offset, u8 *data, u32 len)

// offset points 32bit words, count counts bytes
//int (*read_wiidisc_callback_t)(void*fp,u32 offset,u32 count,void*iobuf);

// connect wiidisc to wbfs_disc
int read_wiidisc_wbfsdisc(void *fp, u32 offset, u32 count, void *iobuf)
{
	//fprintf(stderr,"read_ww(%p, %u, %u, %p)\n", fp, offset, count, iobuf);
	//fflush(stderr);
    int ret = wbfs_disc_read((wbfs_disc_t*)fp, offset, iobuf, count);
    return ret;
}

// verbose/force variant
int read_wiidisc_wbfsdisc_errcheck(void *fp, u32 offset, u32 count, void *iobuf)
{
    int ret = read_wiidisc_wbfsdisc(fp, offset, count, iobuf);
    if (ret) {
		if (print_read_err(offset, count) == 0) {
			// forced
			memset(iobuf, 0, count);
			ret = 0;
		}
    }
    return ret;
}

int wbfs_extract_file(wbfs_disc_t*d, char *path, void **data)
{
        wiidisc_t *wd = 0;
        int ret = 0;

        wd = wd_open_disc(read_wiidisc_wbfsdisc_errcheck, d);
        if (!wd) {
            ERROR("opening wbfs disc");
				return -1;
        }
        wd->extracted_size = 0;
        *data = wd_extract_file(wd, ONLY_GAME_PARTITION, path);
        ret = wd->extracted_size;
        if (!*data) {
                //ERROR("file not found");
                ret = -1;
        }
        wd_close_disc(wd);
error:
        return ret;
}



```

`wbfs_file_2.9-master/source/libwbfs/libwbfs.h`:

```h
#ifndef LIBWBFS_H
#define LIBWBFS_H

#include "libwbfs_os.h" // this file is provided by the project wanting to compile libwbfs
#include "wiidisc.h"

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */

typedef u32 be32_t;
typedef u16 be16_t;


 
typedef struct wbfs_head
{
        be32_t magic;
        // parameters copied in the partition for easy dumping, and bug reports
        be32_t n_hd_sec;	       // total number of hd_sec in this partition
        u8  hd_sec_sz_s;       // sector size in this partition
        u8  wbfs_sec_sz_s;     // size of a wbfs sec
        u8  padding3[2];
        u8  disc_table[0];	// size depends on hd sector size
}__attribute((packed)) wbfs_head_t ;

typedef struct wbfs_disc_info
{
        u8 disc_header_copy[0x100];
        be16_t wlba_table[0];
}wbfs_disc_info_t;

//  WBFS first wbfs_sector structure:
//
//  -----------
// | wbfs_head |  (hd_sec_sz)
//  -----------
// |	       |
// | disc_info |
// |	       |
//  -----------
// |	       |
// | disc_info |
// |	       |
//  -----------
// |	       |
// | ...       |
// |	       |
//  -----------
// |	       |
// | disc_info |
// |	       |
//  -----------
// |	       |
// |freeblk_tbl|
// |	       |
//  -----------
//

// callback definition. Return 1 on fatal error (callback is supposed to make retries until no hopes..)
typedef int (*rw_sector_callback_t)(void*fp,u32 lba,u32 count,void*iobuf);
typedef void (*progress_callback_t)(int status,int total);
typedef void (*close_callback_t)(void*fp);


typedef struct wbfs_s
{
        wbfs_head_t *head;

        /* hdsectors, the size of the sector provided by the hosting hard drive */
        u32 hd_sec_sz;
        u8  hd_sec_sz_s; // the power of two of the last number
        u32 n_hd_sec;	 // the number of hd sector in the wbfs partition

        /* standard wii sector (0x8000 bytes) */
        u32 wii_sec_sz; 
        u8  wii_sec_sz_s;
        u32 n_wii_sec;
        u32 n_wii_sec_per_disc;
        
        /* The size of a wbfs sector */
        u32 wbfs_sec_sz;
        u32 wbfs_sec_sz_s; 
        u16 n_wbfs_sec;   // this must fit in 16 bit!
        u16 n_wbfs_sec_per_disc;   // size of the lookup table

        u32 part_lba;
        /* virtual methods to read write the partition */
        rw_sector_callback_t read_hdsector;
        rw_sector_callback_t write_hdsector;
		close_callback_t close_hd;
        void *callback_data;

        u16 max_disc;
        u32 freeblks_lba;
        u32 *freeblks;
        u16 disc_info_sz;

        u8  *tmp_buffer;  // pre-allocated buffer for unaligned read
        
        u32 n_disc_open;
       
}wbfs_t;

typedef struct wbfs_disc_s
{
        wbfs_t *p;
        wbfs_disc_info_t  *header;	  // pointer to wii header
        int i;		  		  // disc index in the wbfs header (disc_table)
}wbfs_disc_t;


#define WBFS_MAGIC (('W'<<24)|('B'<<16)|('F'<<8)|('S'))

/*! @brief open a MSDOS partitionned harddrive. This tries to find a wbfs partition into the harddrive 
   @param read_hdsector,write_hdsector: accessors to a harddrive
   @hd_sector_size: size of the hd sector. Can be set to zero if the partition in already initialized
   @num_hd_sector:  number of sectors in this disc. Can be set to zero if the partition in already initialized
   @reset: not implemented, This will format the whole harddrive with one wbfs partition that fits the whole disk.
   calls wbfs_error() to have textual meaning of errors
   @return NULL in case of error
*/
wbfs_t*wbfs_open_hd(rw_sector_callback_t read_hdsector,
                 rw_sector_callback_t write_hdsector,
                 void *callback_data,
                 int hd_sector_size, int num_hd_sector, int reset);

/*! @brief open a wbfs partition
   @param read_hdsector,write_hdsector: accessors to the partition
   @hd_sector_size: size of the hd sector. Can be set to zero if the partition in already initialized
   @num_hd_sector:  number of sectors in this partition. Can be set to zero if the partition in already initialized
   @partition_lba:  The partitio offset if you provided accessors to the whole disc.
   @reset: initialize the partition with an empty wbfs.
   calls wbfs_error() to have textual meaning of errors
   @return NULL in case of error
*/
wbfs_t*wbfs_open_partition(rw_sector_callback_t read_hdsector,
                           rw_sector_callback_t write_hdsector,
                           void *callback_data,
                           int hd_sector_size, int num_hd_sector, u32 partition_lba, int reset);


/*! @brief close a wbfs partition, and sync the metadatas to the disc */
void wbfs_close(wbfs_t*);

/*! @brief open a disc inside a wbfs partition use a 6 char discid+vendorid
  @return NULL if discid is not present
*/
wbfs_disc_t *wbfs_open_disc(wbfs_t* p, u8 *diskid);

/*! @brief close a already open disc inside a wbfs partition */
void wbfs_close_disc(wbfs_disc_t*d);

u32 wbfs_sector_used(wbfs_t *p,wbfs_disc_info_t *di);
u32 wbfs_sector_used2(wbfs_t *p,wbfs_disc_info_t *di, u32 *last_blk);

/*! @brief accessor to the wii disc
  @param d: a pointer to already open disc
  @param offset: an offset inside the disc, *points 32bit words*, allowing to access 16GB data
  @param len: The length of the data to fetch, in *bytes*
 */
// offset is pointing 32bit words to address the whole dvd, although len is in bytes
int wbfs_disc_read(wbfs_disc_t*d,u32 offset, u8 *data, u32 len);

/*! @return the number of discs inside the paritition */
u32 wbfs_count_discs(wbfs_t*p);
/*! get the disc info of ith disc inside the partition. It correspond to the first 0x100 bytes of the wiidvd
  http://www.wiibrew.org/wiki/Wiidisc#Header
  @param i: index of the disc inside the partition
  @param header: pointer to 0x100 bytes to write the header
  @size: optional pointer to a 32bit word that will get the size in 32bit words of the DVD taken on the partition.
*/
u32 wbfs_get_disc_info(wbfs_t*p, u32 i,u8 *header,int header_size,u32 *size); 

/*! get the number of used block of the partition.
  to be multiplied by p->wbfs_sec_sz (use 64bit multiplication) to have the number in bytes
*/
u32 wbfs_count_usedblocks(wbfs_t*p);

/******************* write access  ******************/

/*! add a wii dvd inside the partition
  @param read_src_wii_disc: a callback to access the wii dvd. offsets are in 32bit, len in bytes!
  @callback_data: private data passed to the callback
  @spinner: a pointer to a function that is regulary called to update a progress bar.
  @sel: selects which partitions to copy.
  @copy_1_1: makes a 1:1 copy, whenever a game would not use the wii disc format, and some data is hidden outside the filesystem.
 */
u32 wbfs_add_disc(wbfs_t*p,read_wiidisc_callback_t read_src_wii_disc, void *callback_data,
                  progress_callback_t spinner,partition_selector_t sel,int copy_1_1);


/*! remove a wiidvd inside a partition */
u32 wbfs_rm_disc(wbfs_t*p, u8* discid);


/*! trim the file-system to its minimum size
  This allows to use wbfs as a wiidisc container
 */
u32 wbfs_trim(wbfs_t*p);

/*! extract a disc from the wbfs, unused sectors are just untouched, allowing descent filesystem to only really usefull space to store the disc.
Even if the filesize is 4.7GB, the disc usage will be less.
 */
u32 wbfs_extract_disc(wbfs_disc_t*d, rw_sector_callback_t write_dst_wii_sector,void *callback_data,progress_callback_t spinner);

/*! extract a file from the wii disc filesystem. 
  E.G. Allows to extract the opening.bnr to install a game as a system menu channel
 */
int wbfs_extract_file(wbfs_disc_t*d, char *path, void **data);

// remove some sanity checks
void wbfs_set_force_mode(int force);

// compressed and real size
u32 wbfs_size_disc(wbfs_t*p,read_wiidisc_callback_t read_src_wii_disc,
                  void *callback_data,partition_selector_t sel,
				  u32 *comp_size, u32 *real_size);

int block_used(u8 *used,u32 i,u32 wblk_sz);

int read_wiidisc_wbfsdisc(void *fp, u32 offset, u32 count, void *iobuf);
int read_wiidisc_wbfsdisc_errcheck(void *fp, u32 offset, u32 count, void *iobuf);

#ifdef __cplusplus
   }
#endif /* __cplusplus */

#endif

```

`wbfs_file_2.9-master/source/libwbfs/libwbfs_linux.c`:

```c
#ifdef __linux__
//#ifdef unix
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <linux/fs.h>
#include <fcntl.h>
#include <unistd.h>

#include "libwbfs.h"

int is_device(char *fname)
{
    struct stat st;
    int ret;
    ret = stat(fname, &st);
    if (ret == -1) {
        perror("stat");
        exit(1);
    }
    // is regular file?
    if (S_ISREG(st.st_mode)) return 0;
    // is block device?
    if (S_ISBLK(st.st_mode)) return 1;
    // something else?
    printf("invalid file type %d", st.st_mode);
	exit(1);
	return 0;
}

static int wbfs_fread_sector(void *_fp,u32 lba,u32 count,void*buf)
{
        FILE*fp =_fp;                                 
        u64 off = lba;
        off*=512ULL;
	if (fseeko(fp, off, SEEK_SET))
        {
                fprintf(stderr,"\n\n%lld %d %p\n",off,count,_fp);
		wbfs_error("error seeking in disc partition");
                return 1;
        }
        if (fread(buf, count*512ULL, 1, fp) != 1){
                wbfs_error("error reading disc");
                return 1;
        }
        return 0;
  
}
static int wbfs_fwrite_sector(void *_fp,u32 lba,u32 count,void*buf)
{
        FILE*fp =_fp;
        u64 off = lba;
        off*=512ULL;
	if (fseeko(fp, off, SEEK_SET))
        {
		wbfs_error("error seeking in disc file");
                return 1;
        }
        if (fwrite(buf, count*512ULL, 1, fp) != 1){
                wbfs_error("error writing disc");
                return 1;
        }
        return 0;
  
}

int get_capacity(char *file,u32 *sector_size,u32 *n_sector)
{
        int fd = open(file,O_RDONLY);
        int ret;
        if(fd<0){
                return 0;
        }
        if (!is_device(file)) {
                // it's a file
                *n_sector = lseek(fd, 0, SEEK_END) / 512;
                *sector_size = 512;
                close(fd);
                return 1;
        }
        // it's a device
        ret = ioctl(fd,BLKSSZGET,sector_size);
        if(ret<0) {
            perror("ioctl(BLKSSZGET)");
            close(fd);
            return 0;
        }
        ret = ioctl(fd,BLKGETSIZE,n_sector);
        if(ret<0) {
            perror("ioctl(BLKGETSIZE)");
            close(fd);
            return 0;
        }
        if(*sector_size>512)
                *n_sector*=*sector_size/512;
        if(*sector_size<512)
                *n_sector/=512/ *sector_size;
        close(fd);
        return 1;
}

/*
wbfs_t *wbfs_try_open_hd(char *fn,int reset)
{
        u32 sector_size, n_sector;
        if(!get_capacity(fn,&sector_size,&n_sector))
                return NULL;
        FILE *f = fopen(fn,"rb+");
        if (!f)
                return NULL;
        return wbfs_open_hd(wbfs_fread_sector,wbfs_fwrite_sector,f,
                            sector_size ,n_sector,reset);
}
*/

wbfs_t *wbfs_try_open_partition(char *fn,int reset)
{
        u32 sector_size, n_sector;
        if(!get_capacity(fn,&sector_size,&n_sector))
                return NULL;
        FILE *f = fopen(fn,"rb+");
        if (!f)
                return NULL;
        return wbfs_open_partition(wbfs_fread_sector,wbfs_fwrite_sector,f,
                                   sector_size ,n_sector,0,reset);
}

/*
wbfs_t *wbfs_try_open(char *disc,char *partition, int reset)
{
        wbfs_t *p = 0;
        if(partition)
                p = wbfs_try_open_partition(partition,reset);
        if (!p && !reset && disc)
                p = wbfs_try_open_hd(disc,0);
        else if(!p && !reset){
                char buffer[32];
                int i;
                for (i='c';i<'z';i++)
                {
                        snprintf(buffer,32,"/dev/sd%c",i);
                        p = wbfs_try_open_hd(buffer,0);
                        if(p)
                        {
                                fprintf(stderr,"using %s\n",buffer);
                                return p;
                        }
                        snprintf(buffer,32,"/dev/hd%c",i);
                        p = wbfs_try_open_hd(buffer,0);
                        if(p)
                        {
                                fprintf(stderr,"using %s\n",buffer);
                                return p;
                        }                        
                }
                wbfs_error("cannot find any wbfs partition (verify permissions))");
        }
        return p;
        
}
*/

#endif

```

`wbfs_file_2.9-master/source/libwbfs/libwbfs_os.h`:

```h
#ifndef LIBWBFS_OS_H
#define LIBWBFS_OS_H

// this file abstract the os integration
// libwbfs_glue.h for segher tools env.

// standard u8, u32 and co types, + fatal
#include "tools.h"
#include <stdio.h>

#define wbfs_fatal(x) fatal(x)
#define wbfs_error(x) fatal(x)

#include <stdlib.h>
//#define wbfs_malloc(x) malloc(x)
// some allocations are not cleared in libwbfs, so,
// we're using calloc to get always the same reproducible output
#define wbfs_malloc(x) calloc(x,1)
#define wbfs_free(x) free(x)
// alloc memory space suitable for disk io
//#define wbfs_ioalloc(x) malloc(x)
#define wbfs_ioalloc(x) calloc(x,1)
#define wbfs_iofree(x) free(x)
/*
inline static void*wbfs_mallocx(size_t s, int line, const char *fun)
{
    printf("m(%x) %s:%d\n", s, fun, line);
    return malloc(s);
}
#define wbfs_malloc(x) wbfs_mallocx(x,__LINE__,__FUNCTION__)

// alloc memory space suitable for disk io
inline static void*wbfs_ioallocx(size_t s, int line, const char *fun)
{
    printf("io(%x) %s:%d\n", s, fun, line);
    return malloc(s);
}
#define wbfs_ioalloc(x) wbfs_ioallocx(x,__LINE__,__FUNCTION__)
*/

#ifdef unix
#include <arpa/inet.h>
#elif defined(WIN32)
#include <winsock.h>
#endif

// endianess tools
#define wbfs_ntohl(x) ntohl(x)
#define wbfs_ntohs(x) ntohs(x)
#define wbfs_htonl(x) htonl(x)
#define wbfs_htons(x) htons(x)

#include <string.h>
#define wbfs_memcmp(x,y,z) memcmp(x,y,z)
#define wbfs_memcpy(x,y,z) memcpy(x,y,z)
#define wbfs_memset(x,y,z) memset(x,y,z)

#endif

```

`wbfs_file_2.9-master/source/libwbfs/libwbfs_osx.c`:

```c
#ifdef __APPLE__
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/disk.h>
#include <fcntl.h>
#include <unistd.h>

#include "libwbfs.h"

int is_device(char *fname)
{
    struct stat st;
    int ret;
    ret = stat(fname, &st);
    if (ret == -1) {
        perror("stat");
        exit(1);
    }
    // is regular file?
    if (S_ISREG(st.st_mode)) return 0;
    // is block device?
    if (S_ISBLK(st.st_mode)) return 1;
    // something else?
    printf("invalid file type %d", st.st_mode);
	exit(1);
	return 0;
}

static int wbfs_fread_sector(void *_fp,u32 lba,u32 count,void*buf)
{
        FILE*fp =_fp;                                 
        u64 off = lba;
        off*=512ULL;
	if (fseeko(fp, off, SEEK_SET))
        {
                fprintf(stderr,"\n\n%lld %d %p\n",off,count,_fp);
		wbfs_error("error seeking in disc partition");
                return 1;
        }
        if (fread(buf, count*512ULL, 1, fp) != 1){
                wbfs_error("error reading disc");
                return 1;
        }
        return 0;
  
}
static int wbfs_fwrite_sector(void *_fp,u32 lba,u32 count,void*buf)
{
        FILE*fp =_fp;
        u64 off = lba;
        off*=512ULL;
	if (fseeko(fp, off, SEEK_SET))
        {
		wbfs_error("error seeking in disc file");
                return 1;
        }
        if (fwrite(buf, count*512ULL, 1, fp) != 1){
                wbfs_error("error writing disc");
                return 1;
        }
        return 0;
  
}

int get_capacity(char *file,u32 *sector_size,u32 *n_sector)
{
        int fd = open(file,O_RDONLY);
        int ret;
        if(fd<0){
                return 0;
        }
        if (!is_device(file)) {
                // it's a file
                *n_sector = lseek(fd, 0, SEEK_END) / 512;
                *sector_size = 512;
                close(fd);
                return 1;
        }
        // it's a device
        ret = ioctl(fd,DKIOCGETBLOCKSIZE,sector_size);
        if(ret<0) {
            perror("ioctl(DKIOCGETBLOCKSIZE)");
            close(fd);
            return 0;
        }
	long long n_sec64;
        ret = ioctl(fd,DKIOCGETBLOCKCOUNT,&n_sec64);
        if(ret<0) {
            perror("ioctl(DKIOCGETBLOCKCOUNT)");
            close(fd);
            return 0;
        }
	*n_sector = (u32)n_sec64;
        if(*sector_size>512)
                *n_sector*=*sector_size/512;
        if(*sector_size<512)
                *n_sector/=512/ *sector_size;
        close(fd);
        return 1;
}

/*
wbfs_t *wbfs_try_open_hd(char *fn,int reset)
{
        u32 sector_size, n_sector;
        if(!get_capacity(fn,&sector_size,&n_sector))
                return NULL;
        FILE *f = fopen(fn,"rb+");
        if (!f)
                return NULL;
        return wbfs_open_hd(wbfs_fread_sector,wbfs_fwrite_sector,f,
                            sector_size ,n_sector,reset);
}
*/

wbfs_t *wbfs_try_open_partition(char *fn,int reset)
{
        u32 sector_size, n_sector;
        if(!get_capacity(fn,&sector_size,&n_sector))
                return NULL;
        FILE *f = fopen(fn,"rb+");
        if (!f)
                return NULL;
        return wbfs_open_partition(wbfs_fread_sector,wbfs_fwrite_sector,f,
                                   sector_size ,n_sector,0,reset);
}

/*
wbfs_t *wbfs_try_open(char *disc,char *partition, int reset)
{
        wbfs_t *p = 0;
        if(partition)
                p = wbfs_try_open_partition(partition,reset);
        if (!p && !reset && disc)
                p = wbfs_try_open_hd(disc,0);
        else if(!p && !reset){
                char buffer[32];
                int i;
                for (i='c';i<'z';i++)
                {
                        snprintf(buffer,32,"/dev/sd%c",i);
                        p = wbfs_try_open_hd(buffer,0);
                        if(p)
                        {
                                fprintf(stderr,"using %s\n",buffer);
                                return p;
                        }
                        snprintf(buffer,32,"/dev/hd%c",i);
                        p = wbfs_try_open_hd(buffer,0);
                        if(p)
                        {
                                fprintf(stderr,"using %s\n",buffer);
                                return p;
                        }                        
                }
                wbfs_error("cannot find any wbfs partition (verify permissions))");
        }
        return p;
        
}
*/

#endif

```

`wbfs_file_2.9-master/source/libwbfs/libwbfs_win32.c`:

```c
#if defined(WIN32) || defined(__CYGWIN__)

#include <windows.h>
#include <winioctl.h>
#include <setupapi.h>
#include <io.h>

#define FSCTL_SET_ZERO_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA)
typedef struct _FILE_ZERO_DATA_INFORMATION {
  LARGE_INTEGER FileOffset;
  LARGE_INTEGER BeyondFinalZero;
} FILE_ZERO_DATA_INFORMATION, *PFILE_ZERO_DATA_INFORMATION;


#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>
#include <ctype.h>

#if defined(__CYGWIN__)
#define _get_osfhandle get_osfhandle
typedef long long off64_t;
#endif

#include "libwbfs.h"
#include "platform.h"

int get_capacity(char *fileName, u32 *sector_size, u32 *sector_count);

void print_error(char *devname)
{
	LPVOID lpMsgBuf;
	DWORD err = GetLastError();
	FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL, err,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf, 0, NULL );
	printf("%s", devname);
	printf("Error: (%d) %s", (int)err, (char*)lpMsgBuf);
}

int file_zero_data(int fd, off64_t offset, off64_t length)
{
	HANDLE fh;
	DWORD dw;
	BOOL bRet;
	FILE_ZERO_DATA_INFORMATION zd;

	fh = (HANDLE)_get_osfhandle(fd);
	if (fh == INVALID_HANDLE_VALUE) {
		print_error("_get_osfhandle");
		return -1;
	}
	zd.FileOffset.QuadPart = offset;
	zd.BeyondFinalZero.QuadPart = offset+length;
	bRet = DeviceIoControl(fh, FSCTL_SET_ZERO_DATA, &zd, sizeof(zd), NULL, 0, &dw, NULL);
	if (!bRet) {
		// Silently ignore this error, because when copying
		// to FAT sparse files are not available
		//print_error("SET_ZERO_DATA");
		return -1;
	}
	return 0;
}

int file_truncate(int fd, off64_t length)
{
	int ret;
	HANDLE fh;
	DWORD dw;
	if (length == 0) return 0;
	fh = (HANDLE)_get_osfhandle(fd);
	if (fh == INVALID_HANDLE_VALUE) {
		print_error("_get_osfhandle");
		return -1;
	}
	//printf("fd: %d fh: %d\n", fd, fh);
	LARGE_INTEGER curr;
	LARGE_INTEGER offs;
	LARGE_INTEGER noff;
	curr.QuadPart = 0;
	// since we're mixing FILE & fd & fh,
	// we have to save and reset the file pointer.
	ret = SetFilePointerEx(fh, curr, &curr, FILE_CURRENT);
	//printf("curr: %I64d\n", curr.QuadPart);
	//printf("off: %I64d\n", length);
	offs.QuadPart = length;
	ret = SetFilePointerEx(fh, offs, &noff, FILE_BEGIN);
	if (ret == 0 || (offs.QuadPart != noff.QuadPart)) {
		print_error("SetFilePointerEx");
		return -1;
	}
	//printf("noff: %I64d\n", noff.QuadPart);
	ret = SetEndOfFile(fh);
	if (ret == 0) {
		print_error("SetEndOfFile");
		return -1;
	}
	// reset file pointer
	length = 0;
	ret = SetFilePointerEx(fh, curr, &noff, FILE_BEGIN);
	if (ret == 0 || curr.QuadPart != noff.QuadPart) {
		print_error("SetFilePointerEx");
		return -1;
	}
	// enable sparse files on windows
	BOOL bRet = DeviceIoControl(fh, FSCTL_SET_SPARSE, NULL, 0, NULL, 0, &dw, NULL);
	if (!bRet) {
		printf("file not sparse (%d)\n", (int)GetLastError());
	}

	return 0;
}

int is_device(char *fname)
{
	if (strncmp(fname, "\\\\.\\", 4) == 0) return 1;
	if (strncmp(fname, "\\\\?\\", 4) == 0) return 1;
	if (strlen(fname) == 2 && fname[1] == ':' && isalpha(fname[0])) return 1;
	return 0;
}

char *get_dev_name(char *name)
{
	static char drivePath[8] = "\\\\?\\Z:";
	
	if (!is_device(name)) {
		return name;
	}
	if (strlen(name) == 2) {
		drivePath[4] = name[0];
		return drivePath;
	}
	return name;
}


static int read_sector(void *_handle, u32 lba, u32 count, void *buf)
{
	HANDLE *handle = (HANDLE *)_handle;
	LARGE_INTEGER large;
	DWORD read;
	u64 offset = lba;
	
	offset *= 512ULL;
	large.QuadPart = offset;

	
	if (SetFilePointerEx(handle, large, NULL, FILE_BEGIN) == FALSE)
	{
		fprintf(stderr, "\n\n%lld %d %p\n", offset, count, _handle);
		wbfs_error("error seeking in hd sector (read)");
		return 1;
	}
	
	read = 0;
	if (ReadFile(handle, buf, count * 512ULL, &read, NULL) == FALSE)
	{
		wbfs_error("error reading hd sector");
		return 1;
	}
	
	return 0;
}

static int write_sector(void *_handle, u32 lba, u32 count, void *buf)
{
	HANDLE *handle = (HANDLE *)_handle;
	LARGE_INTEGER large;
	DWORD written;
	u64 offset = lba;

	offset *= 512ULL;
	large.QuadPart = offset;

	if (SetFilePointerEx(handle, large, NULL, FILE_BEGIN) == FALSE)
	{
		wbfs_error("error seeking in hd sector (write)");
		return 1;
	}

	written = 0;
	if (WriteFile(handle, buf, count * 512ULL, &written, NULL) == FALSE)
	{
		wbfs_error("error writing hd sector");
		return 1;
	}
	
	return 0;
  
}

static void close_handle(void *handle)
{
	CloseHandle((HANDLE *)handle);
}

int get_capacity(char *fileName, u32 *sector_size, u32 *sector_count)
{
	DISK_GEOMETRY dg;
	PARTITION_INFORMATION pi;
	DWORD bytes;
	char *name = get_dev_name(fileName);
	HANDLE *handle = CreateFile(name, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_NO_BUFFERING, NULL);

	if (handle == INVALID_HANDLE_VALUE)
	{
		print_error(fileName);
		wbfs_error("could not open drive");
		return 0;
	}
	
	if (DeviceIoControl(handle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &dg, sizeof(DISK_GEOMETRY), &bytes, NULL) == FALSE)
	{
		print_error(fileName);
		CloseHandle(handle);
		wbfs_error("could not get drive geometry");
		return 0;
	}

	*sector_size = dg.BytesPerSector;

	if (DeviceIoControl(handle, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &pi, sizeof(PARTITION_INFORMATION), &bytes, NULL) == FALSE)
	{
		print_error(fileName);
		CloseHandle(handle);
		wbfs_error("could not get partition info");
		return 0;
	}

	*sector_count = (u32)(pi.PartitionLength.QuadPart / dg.BytesPerSector);
	
	CloseHandle(handle);
	return 1;
}

/*
wbfs_t *wbfs_try_open_hd(char *driveName, int reset)
{
	wbfs_error("no direct harddrive support");
	return 0;
}
*/


wbfs_t *wbfs_try_open_partition(char *partitionName, int reset)
{
	HANDLE *handle;
	wbfs_t * ret;
	char *devName;
	u32 sector_size, sector_count;
	
	if (!is_device(partitionName))
	{
		wbfs_error("bad drive name");
		return NULL;
	}
	devName = get_dev_name(partitionName);
	//printf("Opening Device: '%s'\n", devName);
	
	if (!get_capacity(devName, &sector_size, &sector_count))
	{
		return NULL;
	}

	//printf("Capacity: %d %d\n", sector_size, sector_count);
	
	handle = CreateFile(devName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_NO_BUFFERING, NULL);
	
	if (handle == INVALID_HANDLE_VALUE)
	{
		print_error(devName);
		return NULL;
	}

	ret= wbfs_open_partition(read_sector, write_sector, handle, sector_size, sector_count, 0, reset);
	if (!ret) CloseHandle(handle);
	else ret->close_hd = close_handle;

	return ret;
}

/*
wbfs_t *wbfs_try_open(char *disc, char *partition, int reset)
{
	wbfs_t *p = 0;
	
	if (partition)
	{
		p = wbfs_try_open_partition(partition,reset);
	}
	
	if (!p && !reset && disc)
	{
		p = 0;
	}
	else if(!p && !reset)
	{
		p = 0;
	}

	return p;
}
*/

#endif


```

`wbfs_file_2.9-master/source/libwbfs/wiidisc.c`:

```c
// Copyright 2009 Kwiirk based on negentig.c:
// Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include "wiidisc.h"

void aes_set_key(u8 *key);
void aes_decrypt(u8 *iv, u8 *inbuf, u8 *outbuf, unsigned long long len);

static void _decrypt_title_key(u8 *tik, u8 *title_key)
{
	u8 common_key[16]={
                0xeb, 0xe4, 0x2a, 0x22, 0x5e, 0x85, 0x93, 0xe4, 0x48, 0xd9, 0xc5, 0x45,
                0x73, 0x81, 0xaa, 0xf7
        };;
	u8 iv[16];

	wbfs_memset(iv, 0, sizeof iv);
	wbfs_memcpy(iv, tik + 0x01dc, 8);
        aes_set_key(common_key);
	//_aes_cbc_dec(common_key, iv, tik + 0x01bf, 16, title_key);
        aes_decrypt(iv, tik + 0x01bf,title_key,16);
}
static u32 _be32(const u8 *p)
{
	return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
}

static void disc_read(wiidisc_t *d,u32 offset, u8 *data, u32 len)
{
        if(data){
                int ret=0;
                if(len==0)
                        return ;
                ret = d->read(d->fp,offset,len,data);
                if(ret)
                        wbfs_fatal("error reading disc");
        }
        if(d->sector_usage_table)
        {
                u32 blockno = offset>>13;
                do
                {
                        d->sector_usage_table[blockno]=1;
                        blockno+=1;
                        if(len>0x8000)
                                len-=0x8000;
                        else
                                len = 0;
                }while(len>0);
        }
}

static void partition_raw_read(wiidisc_t *d,u32 offset, u8 *data, u32 len)
{
	disc_read(d, d->partition_raw_offset + offset, data, len);
}

static void partition_read_block(wiidisc_t *d,u32 blockno, u8 *block)
{
        u8*raw = d->tmp_buffer;
	u8 iv[16];
	u32 offset;
        if(d->sector_usage_table)
                d->sector_usage_table[d->partition_block+blockno]=1;
        offset = d->partition_data_offset + ((0x8000>>2) * blockno);
        partition_raw_read(d,offset, raw, 0x8000);

        // decrypt data
        memcpy(iv, raw + 0x3d0, 16);
        aes_set_key(d->disc_key);
        aes_decrypt(iv, raw + 0x400,block,0x7c00);
}

static void partition_read(wiidisc_t *d,u32 offset, u8 *data, u32 len,int fake)
{
	u8 *block = d->tmp_buffer2;
	u32 offset_in_block;
	u32 len_in_block;
        if(fake &&  d->sector_usage_table==0)
                return;

	while(len) {
		offset_in_block = offset % (0x7c00>>2);
		len_in_block = 0x7c00 - (offset_in_block<<2);
		if (len_in_block > len)
			len_in_block = len;
                if(!fake){
                        partition_read_block(d,offset / (0x7c00>>2), block);
                        wbfs_memcpy(data, block + (offset_in_block<<2), len_in_block);
                }else
                        d->sector_usage_table[d->partition_block+(offset/(0x7c00>>2))]=1;
		data += len_in_block;
		offset += len_in_block>>2;
		len -= len_in_block;
	}
}


static u32 do_fst(wiidisc_t *d,u8 *fst, const char *names, u32 i)
{
	u32 offset;
	u32 size;
	const char *name;
	u32 j;

	name = names + (_be32(fst + 12*i) & 0x00ffffff);
	size = _be32(fst + 12*i + 8);

	if (i == 0) {
		for (j = 1; j < size && !d->extracted_buffer; ){
			j = do_fst(d,fst, names, j);
                }
		return size;
	}
        //printf("name    %s\n",name);

	if (fst[12*i]) {

		for (j = i + 1; j < size && !d->extracted_buffer; )
			j = do_fst(d,fst, names, j);

		return size;
	} else {
		offset = _be32(fst + 12*i + 4);
                if(d->extract_pathname && strcasecmp(name, d->extract_pathname)==0)
                {
                        d->extracted_buffer = wbfs_ioalloc(size);
                        d->extracted_size = size;
                        partition_read(d,offset, d->extracted_buffer, size,0);
                }else
                        partition_read(d,offset, 0, size,1);
		return i + 1;
	}
}

static void do_files(wiidisc_t*d)
{
	u8 *b = wbfs_ioalloc(0x480); // XXX: determine actual header size
	u32 dol_offset;
	u32 fst_offset;
	u32 fst_size;
	u32 apl_offset;
	u32 apl_size;
	u8 *apl_header = wbfs_ioalloc(0x20);
	u8 *fst;
	u32 n_files;
	partition_read(d,0, b, 0x480,0);

	dol_offset = _be32(b + 0x0420);
	fst_offset = _be32(b + 0x0424);
	fst_size = _be32(b + 0x0428)<<2;

	apl_offset = 0x2440>>2;
	partition_read(d,apl_offset, apl_header, 0x20,0);
	apl_size = 0x20 + _be32(apl_header + 0x14) + _be32(apl_header + 0x18);
        // fake read dol and partition
        partition_read(d,apl_offset, 0, apl_size,1);
        partition_read(d,dol_offset, 0,  (fst_offset - dol_offset)<<2,1);
        

	fst = wbfs_ioalloc(fst_size);
	if (fst == 0)
		wbfs_fatal("malloc fst");
	partition_read(d,fst_offset, fst, fst_size,0);
	n_files = _be32(fst + 8);

	if (d->extract_pathname && *d->extract_pathname == 0) {
		// if empty pathname requested return fst
		d->extracted_buffer = fst;
		d->extracted_size = fst_size;
		d->extract_pathname = NULL;
		// skip do_fst if only fst requested
		n_files = 0;
	}

	if (n_files > 1)
		do_fst(d,fst, (char *)fst + 12*n_files, 0);
	wbfs_iofree(b);
	wbfs_iofree(apl_header);
	if (fst != d->extracted_buffer)
		wbfs_iofree(fst);
}

static void do_partition(wiidisc_t*d)
{
	u8 *tik = wbfs_ioalloc(0x2a4);
        u8 *b = wbfs_ioalloc(0x1c);
	u64 tmd_offset;
	u32 tmd_size;
	u8 *tmd;
	u64 cert_offset;
	u32 cert_size;
	u8 *cert;
	u64 h3_offset;

	// read ticket, and read some offsets and sizes
	partition_raw_read(d,0, tik, 0x2a4);
	partition_raw_read(d,0x2a4>>2, b, 0x1c);

	tmd_size = _be32(b);
	tmd_offset = _be32(b + 4);
	cert_size = _be32(b + 8);
	cert_offset = _be32(b + 0x0c);
	h3_offset = _be32(b + 0x10);
	d->partition_data_offset = _be32(b + 0x14);
        d->partition_block = (d->partition_raw_offset+d->partition_data_offset)>>13;
	tmd = wbfs_ioalloc(tmd_size);
	if (tmd == 0)
		wbfs_fatal("malloc tmd");
	partition_raw_read(d,tmd_offset, tmd, tmd_size);

	cert = wbfs_ioalloc(cert_size);
	if (cert == 0)
		wbfs_fatal("malloc cert");
	partition_raw_read(d,cert_offset, cert, cert_size);


	_decrypt_title_key(tik, d->disc_key);

	partition_raw_read(d,h3_offset, 0, 0x18000);
        wbfs_iofree(b);
        wbfs_iofree(tik);
	wbfs_iofree(cert);
	wbfs_iofree(tmd);

	do_files(d);

}
static int test_partition_skip(u32 partition_type,partition_selector_t part_sel)
{
        switch(part_sel)
        {
        case ALL_PARTITIONS:
                return 0;
        case REMOVE_UPDATE_PARTITION:
                return (partition_type==1);
        case ONLY_GAME_PARTITION:
                return (partition_type!=0);
        default:
                return (partition_type!=part_sel);
        }
} 
static void do_disc(wiidisc_t*d)
{
	u8 *b = wbfs_ioalloc(0x100);
	u64 partition_offset[32]; // XXX: don't know the real maximum
	u64 partition_type[32]; // XXX: don't know the real maximum
	u32 n_partitions;
        u32 magic;
	u32 i;
	disc_read(d,0, b, 0x100);
        magic=_be32(b+24);
        if(magic!=0x5D1C9EA3){
                wbfs_error("not a wii disc");
                return ;
        }
	disc_read(d,0x40000>>2, b, 0x100);
	n_partitions = _be32(b);
	disc_read(d,_be32(b + 4), b, 0x100);
	for (i = 0; i < n_partitions; i++){
		partition_offset[i] = _be32(b + 8 * i);
		partition_type[i] = _be32(b + 8 * i+4);
        }
	for (i = 0; i < n_partitions; i++) {
                d->partition_raw_offset = partition_offset[i];
                if(!test_partition_skip(partition_type[i],d->part_sel))
                        do_partition(d);
	}
        wbfs_iofree(b);
}

wiidisc_t *wd_open_disc(read_wiidisc_callback_t read,void*fp)
{
        wiidisc_t *d = wbfs_malloc(sizeof(wiidisc_t));
        if(!d)
                return 0;
        wbfs_memset(d,0,sizeof(wiidisc_t));
        d->read = read;
        d->fp = fp;
        d->part_sel = ALL_PARTITIONS;
        d->tmp_buffer = wbfs_ioalloc(0x8000);
        d->tmp_buffer2 = wbfs_malloc(0x8000);

        return d;
}
void wd_close_disc(wiidisc_t *d)
{
        wbfs_iofree(d->tmp_buffer);
        wbfs_free(d->tmp_buffer2);
        wbfs_free(d);
}
// returns a buffer allocated with wbfs_ioalloc() or NULL if not found of alloc error
// XXX pathname not implemented. files are extracted by their name. 
// first file found with that name is returned.
u8 * wd_extract_file(wiidisc_t *d, partition_selector_t partition_type, char *pathname)
{
        u8 *retval = 0;
        d->extract_pathname = pathname;
        d->extracted_buffer = 0;
        d->part_sel = partition_type;
        do_disc(d);
        d->extract_pathname = 0;
        d->part_sel = ALL_PARTITIONS;
        retval = d->extracted_buffer;
        d->extracted_buffer = 0;
        return retval;
}

void wd_build_disc_usage(wiidisc_t *d, partition_selector_t selector, u8* usage_table)
{
        d->sector_usage_table = usage_table;
        wbfs_memset(usage_table,0,143432*2);

        // these sectors are always copied
        usage_table[ 0 ] = 1;
        usage_table[ WII_PART_INFO_OFF / WII_SECTOR_SIZE ] = 1;
        usage_table[ WII_REGION_OFF    / WII_SECTOR_SIZE ] = 1;

        d->part_sel = selector;
        do_disc(d);
        d->part_sel = ALL_PARTITIONS;
        d->sector_usage_table = 0;
}

void wd_fix_partition_table(wiidisc_t *d, partition_selector_t selector, u8* partition_table)
{
        u8 *b = partition_table;
	u32 partition_offset; 
	u32 partition_type; 
	u32 n_partitions,i,j;
        u32 *b32;
        if(selector == ALL_PARTITIONS)
                return;
	n_partitions = _be32(b);
        if(_be32(b + 4)-(0x40000>>2) >0x50)
                wbfs_fatal("cannot modify this partition table. Please report the bug.");
        
        b += (_be32(b + 4)-(0x40000>>2))*4;
        j=0;
	for (i = 0; i < n_partitions; i++){
		partition_offset = _be32(b + 8 * i);
		partition_type = _be32(b + 8 * i+4);
                if(!test_partition_skip(partition_type,selector))
                {
                        b32 = (u32*)(b + 8 * j);
                        b32[0] = wbfs_htonl(partition_offset);
                        b32[1] = wbfs_htonl(partition_type);
                        j++;
                }
        }
        b32 = (u32*)(partition_table);
        *b32 = wbfs_htonl(j);
}


```

`wbfs_file_2.9-master/source/libwbfs/wiidisc.h`:

```h
#ifndef WIIDISC_H
#define WIIDISC_H
#include <stdio.h>
#include "libwbfs_os.h" // this file is provided by the project wanting to compile libwbfs and wiidisc

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */
#if 0 //removes extra automatic indentation by editors
   }
#endif
// callback definition. Return 1 on fatal error (callback is supposed to make retries until no hopes..)
// offset points 32bit words, count counts bytes
typedef int (*read_wiidisc_callback_t)(void*fp,u32 offset,u32 count,void*iobuf);

enum // some constants
{
    WII_SECTOR_SIZE		= 0x8000,
    WII_SECTORS_SINGLE_LAYER	= 143432,
    WII_SECTORS_DOUBLE_LAYER	= 2 * WII_SECTORS_SINGLE_LAYER,
    WII_MAX_SECTORS		= WII_SECTORS_DOUBLE_LAYER,

    WII_TITLE_OFF		= 0x20,
    WII_TITLE_SIZE		= 0x40,

    WII_MAX_PART_INFO		=       4,
    WII_PART_INFO_OFF		= 0x40000,
    WII_REGION_OFF		= 0x4e000,
    WII_MAX_PART_TABLE		=    0x40,
    WII_H3_SIZE			= 0x18000,
};

typedef enum{
        UPDATE_PARTITION_TYPE=0,
        GAME_PARTITION_TYPE,
        OTHER_PARTITION_TYPE,
        // value in between selects partition types of that value
        ALL_PARTITIONS=0xffffffff-3,
        REMOVE_UPDATE_PARTITION, // keeps game + channel installers
        ONLY_GAME_PARTITION,
}partition_selector_t;

typedef struct wiidisc_s
{
        read_wiidisc_callback_t read;
        void *fp;
        u8 *sector_usage_table;

        // everything points 32bit words.
        u32 disc_raw_offset;
        u32 partition_raw_offset;
        u32 partition_data_offset;
        u32 partition_data_size;
        u32 partition_block;
        
        u8 *tmp_buffer;
        u8 *tmp_buffer2;
        u8 disc_key[16];
        int dont_decrypt;

        partition_selector_t part_sel;

        char *extract_pathname;
        u8  *extracted_buffer;
        int extracted_size;
}wiidisc_t;

wiidisc_t *wd_open_disc(read_wiidisc_callback_t read,void*fp);
void wd_close_disc(wiidisc_t *);
// returns a buffer allocated with wbfs_ioalloc() or NULL if not found of alloc error
u8 * wd_extract_file(wiidisc_t *d, partition_selector_t partition_type, char *pathname);

void wd_build_disc_usage(wiidisc_t *d, partition_selector_t selector, u8* usage_table);

// effectively remove not copied partition from the partition table.
void wd_fix_partition_table(wiidisc_t *d, partition_selector_t selector, u8* partition_table);

#if 0
{
#endif
#ifdef __cplusplus
   }
#endif /* __cplusplus */

#endif

```

`wbfs_file_2.9-master/source/negentig.c`:

```c
// Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "tools.h"
#include "libwbfs.h"
static int just_a_partition = 0;
static int wbfs = 0;
static int dump_partition_data = 0;
static u32 max_size_to_auto_analyse = 0x1000000;
static int uncompress_yaz0 = 1;
static int unpack_rarc = 1;

static FILE *disc_fp;
static FILE *disc_fp2;

static u64 partition_raw_offset;
static u64 partition_data_offset;
static u64 partition_data_size;
static u8 h3[0x18000];

u8 disc_key[16];
static char* extract_one_file = 0;
static u32 errors = 0;
static int try_read_partition=0;
wbfs_disc_t *wbfs_disc;
static void seek(u64 offset)
{
	if (fseeko(disc_fp, offset, SEEK_SET))
		fatal("error seeking in disc file");
}
static void disc_read(u64 offset, u8 *data, u32 len)
{
        if(wbfs){
                wbfs_disc_read(wbfs_disc,offset/4, data, len);

        }
        else{
                seek(offset);
                if (fread(data, len, 1, disc_fp) != 1 && !try_read_partition)
                        fatal("error reading disc");
        }
}
static int read_sector(void *_fp,u32 lba,u32 count,void*buf)
{
        FILE*fp =_fp;
//        printf("read sector %X %X\n",lba,count);
	if (fseeko(fp, lba*512ULL, SEEK_SET))
		fatal("error seeking in disc file");
        if (fread(buf, count*512ULL, 1, fp) != 1)
                fatal("error reading disc");
//        hexdump(buf,count*512);
        return 0;
  
}
static void partition_raw_read(u64 offset, u8 *data, u32 len)
{
	disc_read(partition_raw_offset + offset, data, len);
}

static void partition_read_block(u64 blockno, u8 *block)
{
	u8 raw[0x8000];
	u8 iv[16];
	u8 h[20];
	u8 *h0, *h1, *h2;
	u32 b1, b2, b3;
	u64 offset;
	u32 i;

	offset = partition_data_offset + 0x8000 * blockno;
	partition_raw_read(offset, raw, 0x8000);

	// decrypt data
	memcpy(iv, raw + 0x3d0, 16);
	aes_cbc_dec(disc_key, iv, raw + 0x400, 0x7c00, block);

	// decrypt hashes
	memset(iv, 0, 16);
	aes_cbc_dec(disc_key, iv, raw, 0x400, raw);

	h0 = raw;
	h1 = raw + 0x280;
	h2 = raw + 0x340;
	b1 = blockno & 7;
	b2 = (blockno >> 3) & 7;
	b3 = blockno >> 6;

	// check H0s
	for (i = 0; i < 31; i++) {
		sha(block + 0x400*i, 0x400, h);
		if (memcmp(h0 + 20*i, h, 20)) {
			//fprintf(stderr, "H0 mismatch for %llx.%02x\n", blockno, i);
			errors |= 1;
		}
	}

	// check H1
	sha(h0, 620, h);
	if (memcmp(h1 + 20*b1, h, 20)) {
		fprintf(stderr, "H1 mismatch for %llx\n", blockno);
		errors |= 2;
	}

	// check H2
	sha(h1, 160, h);
	if (memcmp(h2 + 20*b2, h, 20)) {
		fprintf(stderr, "H2 mismatch for %llx\n", blockno);
		errors |= 4;
	}

	// check H3
	sha(h2, 160, h);
	if (memcmp(h3 + 20*b3, h, 20)) {
		fprintf(stderr, "H3 mismatch for %llx\n", blockno);
		errors |= 8;
	}

/*        if(errors&0xf)
                fatal("stop");
*/}

static void partition_read(u64 offset, u8 *data, u32 len)
{
	u8 block[0x8000];
	u32 offset_in_block;
	u32 len_in_block;

	if (just_a_partition)
		disc_read(offset, data, len);
	else while(len) {
		offset_in_block = offset % 0x7c00;
		len_in_block = 0x7c00 - offset_in_block;
		if (len_in_block > len)
			len_in_block = len;
		partition_read_block(offset / 0x7c00, block);
		memcpy(data, block + offset_in_block, len_in_block);
		data += len_in_block;
		offset += len_in_block;
		len -= len_in_block;
	}
}


static void do_data(u64 size)
{
	u8 data[0x7c00];
	u64 offset;
	u64 remaining_size;
	u32 block_size;
	FILE *fp;

	size = (size / 0x8000) * 0x7c00;

	fp = fopen("###dat###", "wb");
	if (fp == 0)
		fatal("cannot open partition output file");

	fprintf(stderr, "\nDumping partition contents...\n");
	offset = 0;
	remaining_size = size;
	while (remaining_size) {
		spinner(offset, size);

		block_size = 0x7c00;
		if (block_size > remaining_size)
			block_size = remaining_size;

		partition_read(offset, data, block_size);
		if (fwrite(data, block_size, 1, fp) != 1)
			fatal("error writing partition");

		offset += block_size;
		remaining_size -= block_size;
	}
	spinner(0, 0);

	fclose(fp);
}

static void copy_file(const char *name, u64 offset, u64 size)
{
	u8 data[0x80000];
	FILE *fp;
	u32 block_size;

	fp = fopen(name, "wb");
	if (fp == 0)
		fatal("cannot open output file");

	while (size) {
		block_size = sizeof data;
		if (block_size > size)
			block_size = size;

		partition_read(offset, data, block_size);
		if (fwrite(data, block_size, 1, fp) != 1)
			printf("error writing output file");

		offset += block_size;
		size -= block_size;
	}

	fclose(fp);
}

static void do_fst_file(const char *name, u64 offset, u64 size)
{
	FILE *fp;
	u8 *data;

	if (size > max_size_to_auto_analyse) {
		copy_file(name, offset, size);

		return;
	}

	data = malloc(size);
	if (data == 0)
		fatal("malloc");
	partition_read(offset, data, size);

	if (uncompress_yaz0 && size >= 8 && memcmp(data, "Yaz0", 4) == 0) {
		u8 *dec;
		u32 dec_size;

		fprintf(stderr, " [Yaz0]");

		dec_size = be32(data + 4);
		dec = malloc(dec_size);
		if (dec == 0)
			fatal("malloc");

		do_yaz0(data, size, dec, dec_size);

		free(data);
		data = dec;
		size = dec_size;
	}

	if (unpack_rarc && size >= 8 && memcmp(data, "RARC", 4) == 0) {
		fprintf(stderr, " [RARC]");
	}

	fp = fopen(name, "wb");
	if (fp == 0)
		fatal("cannot open output file");
	if (size!=0 && fwrite(data, size, 1, fp) != 1){
                fatal("error writing output file \n");

        }
	fclose(fp);

	free(data);
}

static u32 do_fst(u8 *fst, const char *names, u32 i, char *indent, int is_last)
{
	u64 offset;
	u32 size;
	const char *name;
	u32 parent;
	u32 j;

	name = names + (be32(fst + 12*i) & 0x00ffffff);
	size = be32(fst + 12*i + 8);

	if (i == 0) {
		fprintf(stderr, "/\n");

		for (j = 1; j < size; )
			j = do_fst(fst, names, j, indent, (j == size - 1));

		return size;
	}

	if (fst[12*i]) {
		parent = be32(fst + 12*i + 4);
		is_last = (be32(fst + 12*parent + 8) == size);
	}

	fprintf(stderr, "%s%c-- %s", indent, "|+"[is_last], name);

	if (fst[12*i]) {
                if(!extract_one_file){
                        if (mkdir(name, 0777))
                                fatal("mkdir");
                        if (chdir(name))
                                fatal("chdir");
                }
		fprintf(stderr, "\n");

		if (is_last)
			strcat(indent, "    ");
		else
			strcat(indent, "|   ");

		for (j = i + 1; j < size; )
			j = do_fst(fst, names, j, indent, (j == size - 1));

		indent[strlen(indent) - 4] = 0;

                if(!extract_one_file){
                        if (chdir(".."))
                                fatal("chdir up");
                }
		return size;
	} else {
		offset = be34(fst + 12*i + 4);
                if(!extract_one_file || strcmp(name,extract_one_file)==0){
                        do_fst_file(name, offset, size);
                }

		fprintf(stderr, "\n");

		return i + 1;
	}
}

static void do_files(void)
{
	u8 b[0x480]; // XXX: determine actual header size
	u64 dol_offset;
	u64 fst_offset;
	u32 fst_size;
	u64 apl_offset;
	u32 apl_size;
	u8 apl_header[0x20];
	u8 *fst;
	char indent[999];
	u32 n_files;

	partition_read(0, b, sizeof b);

	fprintf(stderr, "\n");
	fprintf(stderr, "Title id: %c%c%c%c\n", b[0], b[1], b[2], b[3]);
	fprintf(stderr, "Group id: %c%c\n", b[4], b[5]);
	fprintf(stderr, "Name: %s\n", b + 0x20);
	fprintf(stderr, "\n");

	dol_offset = be34(b + 0x0420);
	fst_offset = be34(b + 0x0424);
	fst_size = be34(b + 0x0428);

	apl_offset = 0x2440;
	partition_read(apl_offset, apl_header, sizeof apl_header);
	apl_size = 0x20 + be32(apl_header + 0x14) + be32(apl_header + 0x18);

	fprintf(stderr, "\tDOL @ %09llx\n", dol_offset);
	fprintf(stderr, "\tFST @ %09llx (size %08x)\n", fst_offset, fst_size);
	fprintf(stderr, "\tAPL @ %09llx (size %08x)\n", apl_offset, apl_size);

	copy_file("###apl###", apl_offset, apl_size);
	copy_file("###dol###", dol_offset, fst_offset - dol_offset);
		// XXX: read the header for getting the size

	fst = malloc(fst_size);
	if (fst == 0)
		fatal("malloc fst");
	partition_read(fst_offset, fst, fst_size);
	n_files = be32(fst + 8);

	fprintf(stderr, "%d entries\n", n_files);
	indent[0] = 0;
	if (n_files > 1)
		do_fst(fst, (char *)fst + 12*n_files, 0, indent, 0);

	free(fst);
}

static void do_partition(void)
{
	u8 tik[0x2a4];
	u8 b[0x1c];
	u64 title_id;
	u64 tmd_offset;
	u32 tmd_size;
	u8 *tmd;
	u64 cert_offset;
	u32 cert_size;
	u8 *cert;
	u64 h3_offset;
	u8 h[20];
	u32 ret;
	char dirname[17];

        try_read_partition=1;
	// read ticket, and read some offsets and sizes
	partition_raw_read(0, tik, sizeof tik);
        memset(b,0, sizeof b);
	partition_raw_read(0x2a4, b, sizeof b);

        try_read_partition=1;

	tmd_size = be32(b);
        if (tmd_size==0){
          fprintf(stderr, "partition removed\n");
          return;
        }
	tmd_offset = be34(b + 4);
	cert_size = be32(b + 8);
	cert_offset = be34(b + 0x0c);
	h3_offset = be34(b + 0x10);
	partition_data_offset = be34(b + 0x14);
	partition_data_size = be34(b + 0x18);

	title_id = be64(tik + 0x01dc);
	fprintf(stderr, "\ttitle id = %016llx\n", title_id);

	fprintf(stderr, "\ttmd size    =  %08x\n", tmd_size);
	fprintf(stderr, "\ttmd offset  = %09llx\n", tmd_offset);
	fprintf(stderr, "\tcert size   =  %08x\n", cert_size);
	fprintf(stderr, "\tcert offset = %09llx\n", cert_offset);
	fprintf(stderr, "\tdata offset = %09llx\n", partition_data_offset);
	fprintf(stderr, "\tdata size   = %09llx %.3fGb\n", partition_data_size,(double)partition_data_size/(1024*1024*1024.));
//        return;
	tmd = malloc(tmd_size);
	if (tmd == 0)
		fatal("malloc tmd");
	partition_raw_read(tmd_offset, tmd, tmd_size);

	cert = malloc(cert_size);
	if (cert == 0)
		fatal("malloc cert");
	partition_raw_read(cert_offset, cert, cert_size);

	ret = check_cert_chain(tik, sizeof tik, cert, cert_size);
	if (ret) {
		fprintf(stderr, "ticket cert failure (%d)\n", ret);
		errors |= 0x20;
	}
	ret = check_cert_chain(tmd, tmd_size, cert, cert_size);
	if (ret) {
		fprintf(stderr, "tmd cert failure (%d)\n", ret);
		errors |= 0x40;
	}

	decrypt_title_key(tik, disc_key);

	partition_raw_read(h3_offset, h3, 0x18000);

	sha(h3, 0x18000, h);
	if (memcmp(tmd + 0x1f4, h, 20)) {
		fprintf(stderr, "H4 mismatch\n");
		errors |= 0x10;
	}

	free(cert);
	free(tmd);

	snprintf(dirname, sizeof dirname, "%016llx", title_id);
        
        if(!extract_one_file){
                if (mkdir(dirname, 0777))
                        fatal("mkdir partition");
                if (chdir(dirname))
                        fatal("chdir partition");
        }
	if (dump_partition_data)
		do_data(partition_data_size);

	do_files();

	if (chdir(".."))
		fatal("chdir up out of partition");
}

static void do_disc(void)
{
	u8 b[0x100];
	u64 partition_offset[32]; // XXX: don't know the real maximum
	u64 partition_type[32]; // XXX: don't know the real maximum
	u32 n_partitions;
	u32 i;

	disc_read(0, b, sizeof b);

	fprintf(stderr, "Title id: %c%c%c%c\n", b[0], b[1], b[2], b[3]);
	fprintf(stderr, "Group id: %c%c\n", b[4], b[5]);
	fprintf(stderr, "Name: %s\n", b + 0x20);
	fprintf(stderr, "\n");

	disc_read(0x40000, b, sizeof b);
	n_partitions = be32(b);

	disc_read(be34(b + 4), b, sizeof b);
	for (i = 0; i < n_partitions; i++){
		partition_offset[i] = be34(b + 8 * i);
		partition_type[i] = be32(b + 8 * i+4);
        }
	fprintf(stderr, "%d partitions:\n", n_partitions);
	for (i = 0; i < n_partitions; i++)
		fprintf(stderr, "\tpartition #%d @ %09llx\n", i,
		        partition_offset[i]);

	for (i = 0; i < n_partitions; i++) {
		fprintf(stderr, "\nDoing partition %d...\n", i);
		fprintf(stderr, "--------------------------------\n");

		partition_raw_offset = partition_offset[i];
                //if(partition_type[i]!=1 || wbfs==0)//dont copy update partition if wbfs
                do_partition();

		//break; // XXX SII: for testing
	}
}

int main(int argc, char **argv)
{
        wbfs_t *wbfs_p=0;
	if (argc != 2 && argc != 3 && argc != 4) {
		fprintf(stderr, "Usage: %s <disc file> %d\n", argv[0],argc);
		return 1;
	}
        if (argc >= 3)
                wbfs = 1;
        if (argc >= 4)
                extract_one_file = argv[3];

        disc_fp = fopen(argv[1], "rb");
        disc_fp2 = fopen("/backup/ptar01/wbfs/test.iso", "rb");
        if (disc_fp == 0)
          fatal("open disc file");
        if(wbfs){
          wbfs_p = wbfs_open_partition(read_sector,NULL,disc_fp,0,0,0,0);
                wbfs_disc = wbfs_open_disc(wbfs_p,(u8*)argv[2]);
        }
	if (just_a_partition)
		do_files();
	else
		do_disc();
        
        if(wbfs){
                wbfs_close_disc(wbfs_disc);
                wbfs_close(wbfs_p);
        }
        fclose(disc_fp);

	if (errors)
		fprintf(stderr, "\n\nErrors detected:\n");
	if (errors & 1)
		fprintf(stderr, "H0 mismatch\n");
	if (errors & 2)
		fprintf(stderr, "H1 mismatch\n");
	if (errors & 4)
		fprintf(stderr, "H2 mismatch\n");
	if (errors & 8)
		fprintf(stderr, "H3 mismatch\n");
	if (errors & 0x10)
		fprintf(stderr, "H4 mismatch\n");
	if (errors & 0x20)
		fprintf(stderr, "ticket cert failure\n");
	if (errors & 0x40)
		fprintf(stderr, "tmd cert failure\n");

	return 0;
}

```

`wbfs_file_2.9-master/source/platform.h`:

```h

#ifdef __MINGW32__
#define fseeko fseeko64
#define ftello ftello64
#define mkdir(N,M) mkdir(N)
#else
#define off64_t off_t
#endif

#if defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
#define FMT_llu "%I64u"
#define FMT_lld "%I64d"
#else
#define FMT_llu "%llu"
#define FMT_lld "%lld"
#endif

#ifdef WIN32
int file_truncate(int fd, off64_t length);
int file_zero_data(int fd, off64_t offset, off64_t length);
char *get_dev_name(char *name);
#else
#define file_truncate ftruncate
#define file_zero_data(fd,offset,length)
#define get_dev_name(NAME) NAME
#define Sleep(MS) usleep(MS*1000)
#endif

int get_capacity(char *file,u32 *sector_size,u32 *n_sector);
int is_device(char *fname);
FILE *fopen_dev(const char *filename, const char *mode);


```

`wbfs_file_2.9-master/source/scrub.c`:

```c
// Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "tools.h"

static u8 used[143432];

int build_disc_usage_table(FILE* fp,u8*table, u64 offset);

int main(int argc, char **argv)
{
        int i;
        FILE* disc_fp;
        FILE* disc2_fp;
        char buf[0x80000];
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <disc file> <out>\n", argv[0]);
		return 1;
	}

	disc_fp = fopen(argv[1], "rb");
	if (disc_fp == 0)
		fatal("open disc file");
	disc2_fp = fopen(argv[2], "wb");
	if (disc2_fp == 0)
		fatal("open disc file");
        
        build_disc_usage_table(disc_fp,used, 0);
        fseeko(disc2_fp,4699979775ULL,SEEK_SET);
        fwrite("\0",1,1,disc2_fp);//write 0 byte at the end to force file size
        for (i=0;i<143432;i++)
        {
                if(used[i]){
                        if(i==0 || !used[i-1]){
                                fseeko(disc_fp,0x8000ULL*i,SEEK_SET);
                                fseeko(disc2_fp,0x8000ULL*i,SEEK_SET);
                        }
                        fread(buf,0x8000,1,disc_fp);
                        if(fwrite(buf,0x8000,1,disc2_fp)!=1)
                                fatal("writing");
                        spinner(i,143432);
                }
        }
        return 0;
}

```

`wbfs_file_2.9-master/source/splits.c`:

```c
// Copyright 2009 oggzee
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include <stdio.h>     /* for printf */
#include <stdlib.h>    /* for exit */
#include <getopt.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>

#include "tools.h"
#include "libwbfs.h"
#include "splits.h"

#include "platform.h"

u64 OPT_split_size = DEF_SPLIT_SIZE;
extern int OPT_verbose;


split_info_t* split_new()
{
	return calloc(1, sizeof(split_info_t));
}

void split_delete(split_info_t *s)
{
	//printf("split_close(%s)\n", s->fname);
	split_close(s);
	free(s);
}

void split_get_fname(split_info_t *s, int idx, char *fname)
{
    strcpy(fname, s->fname);
    if (idx == 0 && s->create_mode) {
        strcat(fname, ".tmp");
    } else if (idx > 0) {
        char *c = fname + strlen(fname) - 1;
        *c = '0' + idx;
    }
}

FILE *split_open_file(split_info_t *s, int idx)
{
    FILE *f = s->f[idx];
    if (f) return f;
    char fname[1024];
    split_get_fname(s, idx, fname);
    char *mode = s->create_mode ? "wb+" : "rb+";
    f = fopen(fname, mode);
    if (!f) {
        if (s->create_mode) {
            printf("ERROR: creating %s\n", fname);
            perror("fopen");
        }
        return NULL;
    }
    if (idx > 0) {
        if (OPT_verbose) {
            printf("%s Split: %d %s          \n",
                s->create_mode ? "Create" : "Read",
                idx, fname);
        }
    }
    s->f[idx] = f;
    return f;
}

int split_fill(split_info_t *s, int idx, off64_t size)
{
    FILE *f = split_open_file(s, idx);
    fseeko(f, 0, SEEK_END);
    off64_t fsize = ftello(f);
    if (fsize < size) {
        printf("TRUNC %d "FMT_lld"\n", idx, size);
        file_truncate(fileno(f), size);
        return 1;
    }
    return 0;
}

FILE *split_get_file(split_info_t *s, u32 lba, u32 *sec_count, int fill)
{
    FILE *f;
    if (lba >= s->total_sec) {
        printf("SPLIT(%s): invalid sector %u / %u\n", s->fname, lba, (u32)s->total_sec);
        return NULL;
    }
    int idx;
    idx = lba / s->split_sec;
    if (idx >= s->max_split) {
        printf("SPLIT: invalid split %d / %d\n", idx, s->max_split - 1);
        return NULL;
    }
    f = s->f[idx];
    if (!f) {
        // opening new, make sure all previous are full
        int i;
        for (i=0; i<idx; i++) {
            if (split_fill(s, i, s->split_size)) {
                //printf("FILL %d\n", i);
            }
        }
        f = split_open_file(s, idx);
    }
    if (!f) {
        printf("SPLIT %d: no file\n", idx);
        return NULL;
    }
    u32 sec = lba % s->split_sec; // inside file
    off64_t off = (off64_t)sec * 512;
    // num sectors till end of file
    u32 to_end = s->split_sec - sec;
    if (*sec_count > to_end) *sec_count = to_end;
    if (s->create_mode && fill) {
        // extend, so that read will be succesfull
        split_fill(s, idx, off + 512 * (*sec_count));
    }
    fseeko(f, off, SEEK_SET);
    return f;
}

int split_read_sector(void *_fp,u32 lba,u32 count,void*buf)
{
    split_info_t *s = _fp;
    FILE*f;                                 
    u64 off = lba;
    off *= 512ULL;
    int i;
    u32 chunk;
    size_t ret;
    //fprintf(stderr,"READ %d %d\n", lba, count);
    for (i=0; i<(int)count; i+=chunk) {
        chunk = count - i;
        f = split_get_file(s, lba+i, &chunk, 1);
        if (!f) {
            fprintf(stderr,"\n\n"FMT_lld" %d %p\n",off,count,_fp);
            wbfs_error("error seeking in disc partition");
            return 1;
        }
        ret = fread(buf+i*512, 512ULL, chunk, f);
        if (ret != chunk) {
            printf("error reading %u %u [%u] %u = %d\n",
                    lba, count, i, chunk, (int)ret);
            wbfs_error("error reading disc");
            return 1;
        }
    }
    return 0;
}

int split_write_sector(void *_fp,u32 lba,u32 count,void*buf)
{
    split_info_t *s = _fp;
    FILE*f;                                 
    u64 off = lba;
    off*=512ULL;
    int i;
    u32 chunk;
    //printf("WRITE %d %d\n", lba, count);
    for (i=0; i<(int)count; i+=chunk) {
        chunk = count - i;
        f = split_get_file(s, lba+i, &chunk, 0);
        //if (chunk != count)
        //	printf("WRITE CHUNK %d %d/%d\n", lba+i, chunk, count);
        if (!f || !chunk) {
            fprintf(stderr,"\n\n"FMT_lld" %d %p\n",off,count,_fp);
            wbfs_error("error seeking in disc partition");
            return 1;
        }
        if (fwrite(buf+i*512, 512ULL, chunk, f) != chunk) {
            wbfs_error("error writing disc");
            return 1;
        }
    }
    return 0;
}

void split_init(split_info_t *s, char *fname)
{
    char *p;
    //printf("SPLIT_INIT %s\n", fname);
    memset(s, 0, sizeof(*s));
    strcpy(s->fname, fname);
    s->max_split = 1;
    p = strrchr(fname, '.');
    if (p && (strcasecmp(p, ".wbfs") == 0)) {
        s->max_split = MAX_SPLIT;
    }
}

void split_set_size(split_info_t *s, u64 split_size, u64 total_size)
{
    s->total_size = total_size;
    s->split_size = split_size;
    s->total_sec  = total_size / 512;
    s->split_sec  = split_size / 512;
}

void split_close(split_info_t *s)
{
    int i;
    char fname[1024];
    char tmpname[1024];
    for (i=0; i<s->max_split; i++) {
        if (s->f[i]) fclose(s->f[i]);
    }
    if (s->create_mode) {
        split_get_fname(s, -1, fname);
        split_get_fname(s, 0, tmpname);
        rename(tmpname, fname);
    }
    memset(s, 0, sizeof(*s));
}

int split_create(split_info_t *s, char *fname, u64 split_size, u64 total_size)
{
    int i;
    FILE *f;
    char sname[1024];
    int error = 0;
    split_init(s, fname);
    s->create_mode = 1;
    // check if any file already exists
    for (i=-1; i<s->max_split; i++) {
        split_get_fname(s, i, sname);
        f = fopen(sname, "rb");
        if (f) {
            printf("Error: file already exists: %s\n", sname);
            fclose(f);
            error = 1;
        }
    }
    if (error) {
        split_init(s, "");
        return -1;
    }
    split_set_size(s, split_size, total_size);
    return 0;
}

int split_open(split_info_t *s, char *fname)
{
    int i;
    u64 size = 0;
    u64 total_size = 0;
    u64 split_size = 0;
    FILE *f;
    split_init(s, fname);
    for (i=0; i<s->max_split; i++) {
        f = split_open_file(s, i);
        if (!f) {
            if (i==0) goto err;
            break;
        }
        // check previous size - all splits except last must be same size
        if (i > 0 && size != split_size) {
            printf("split %d: invalid size "FMT_lld"", i, size);
            goto err;
        }
        // get size
        fseeko(f, 0, SEEK_END);
        size = ftello(f);
        // check sector alignment
        if (size % 512) {
            printf("split %d: size ("FMT_lld") not sector (512) aligned!", i, size);
        }
        // first sets split size
        if (i==0) {
            split_size = size;
        }
        total_size += size;
    }
    split_set_size(s, split_size, total_size);
    return 0;
err:
    split_close(s);
    return -1;
}

int split_truncate(split_info_t *s, off64_t full_size)
{
    FILE *f;
    off64_t size;
    int i, ret;
    char fname[1024];
    for (i=0; i<s->max_split; i++) {
        size = full_size;
        if (size > (off64_t)s->split_size) {
            size = s->split_size;
        }
        if (size) {
            // truncate
            f = split_open_file(s, i);
            // flush & seek because we're mixing FILE/fd/fh
            fflush(f);
            fseeko(f, 0, SEEK_SET);
            //printf("TRUNC %d "FMT_lld"\n", i, size);
            ret = file_truncate(fileno(f), size);
            if (ret) {
                split_get_fname(s, i, fname);
                printf("ERROR: TRUNCATE %s %d "FMT_lld"\n", fname, i, size);
                return -1;
            }
        } else {
            // remove empty
            f = s->f[i];
            if (f) {
                fclose(f);
                s->f[i] = NULL;
            }
            split_get_fname(s, i, fname);
            remove(fname);
        }
        full_size -= size;
    }
    return 0;
}



```

`wbfs_file_2.9-master/source/splits.h`:

```h
// Copyright 2009 Kwiirk
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include <stdio.h>     /* for printf */
#include <stdlib.h>    /* for exit */
#include <getopt.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>

#include "tools.h"
#include "libwbfs.h"

#include "platform.h"

// 4gb - 32kb (1 wii sector)
#define SPLIT_SIZE_4 ((u64)4LL * 1024 * 1024 * 1024 - 32 * 1024)

// 2gb - 32kb (1 wii sector)
#define SPLIT_SIZE_2 ((u64)2LL * 1024 * 1024 * 1024 - 32 * 1024)

// no split
#define SPLIT_SIZE_0 ((u64)10000000000LL)

#define DEF_SPLIT_SIZE SPLIT_SIZE_4

extern u64 OPT_split_size;
extern int OPT_split_verbose;

#define MAX_SPLIT 10

typedef struct split_info
{
	char fname[1024];
	FILE *f[MAX_SPLIT];
	u32 split_sec;
	u32 total_sec;
	u64 split_size;
	u64 total_size;
	int create_mode;
	int max_split;
} split_info_t;

split_info_t* split_new();
void split_delete(split_info_t*s);
void split_get_fname(split_info_t *s, int idx, char *fname);
FILE *split_open_file(split_info_t *s, int idx);
int  split_fill(split_info_t *s, int idx, off64_t size);
FILE *split_get_file(split_info_t *s, u32 lba, u32 *sec_count, int fill);
int  split_read_sector(void *_fp,u32 lba,u32 count,void*buf);
int  split_write_sector(void *_fp,u32 lba,u32 count,void*buf);
void split_init(split_info_t *s, char *fname);
void split_set_size(split_info_t *s, u64 split_size, u64 total_size);
int  split_create(split_info_t *s, char *fname, u64 split_size, u64 total_size);
int  split_open(split_info_t *s, char *fname);
int  split_truncate(split_info_t *s, off64_t full_size);
void split_close(split_info_t *s);


```

`wbfs_file_2.9-master/source/tools.c`:

```c
// Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#include "tools.h"

#include <stddef.h>	// to accommodate certain broken versions of openssl
#include <openssl/md5.h>
#include <openssl/aes.h>
#include <openssl/sha.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <sys/time.h>
#include <math.h>
//
// basic data types
//

u16 be16(const u8 *p)
{
	return (p[0] << 8) | p[1];
}

u32 be32(const u8 *p)
{
	return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
}

u64 be64(const u8 *p)
{
	return ((u64)be32(p) << 32) | be32(p + 4);
}

u64 be34(const u8 *p)
{
	return 4 * (u64)be32(p);
}

void wbe16(u8 *p, u16 x)
{
	p[0] = x >> 8;
	p[1] = x;
}

void wbe32(u8 *p, u32 x)
{
	wbe16(p, x >> 16);
	wbe16(p + 2, x);
}

void wbe64(u8 *p, u64 x)
{
	wbe32(p, x >> 32);
	wbe32(p + 4, x);
}

//
// crypto
//

void md5(u8 *data, u32 len, u8 *hash)
{
	MD5(data, len, hash);
}

void sha(u8 *data, u32 len, u8 *hash)
{
	SHA1(data, len, hash);
}

void get_key(const char *name, u8 *key, u32 len)
{
	char path[256];
	char *home;
	FILE *fp;

	home = getenv("HOME");
	if (home == 0)
		fatal("cannot find HOME");
	snprintf(path, sizeof path, "%s/.wii/%s", home, name);

	fp = fopen(path, "rb");
	if (fp == 0)
		fatal("cannot open %s", name);
	if (fread(key, len, 1, fp) != 1)
		fatal("error reading %s", name);
	fclose(fp);
}

void aes_cbc_dec(u8 *key, u8 *iv, u8 *in, u32 len, u8 *out)
{
	AES_KEY aes_key;

	AES_set_decrypt_key(key, 128, &aes_key);
	AES_cbc_encrypt(in, out, len, &aes_key, iv, AES_DECRYPT);
}

void aes_cbc_enc(u8 *key, u8 *iv, u8 *in, u32 len, u8 *out)
{
	AES_KEY aes_key;

	AES_set_encrypt_key(key, 128, &aes_key);
	AES_cbc_encrypt(in, out, len, &aes_key, iv, AES_ENCRYPT);
}

void decrypt_title_key(u8 *tik, u8 *title_key)
{
	u8 common_key[16];
	u8 iv[16];

	get_key("common-key", common_key, 16);

	memset(iv, 0, sizeof iv);
	memcpy(iv, tik + 0x01dc, 8);
	aes_cbc_dec(common_key, iv, tik + 0x01bf, 16, title_key);
        printf("title key: %02x %02x %02x\n",title_key[0],title_key[1],title_key[2]);
}

static u8 root_key[0x204];
static u8 *get_root_key(void)
{
	//get_key("root-key", root_key, sizeof root_key);
	return root_key;
}

static u32 get_sig_len(u8 *sig)
{
	u32 type;

	type = be32(sig);
	switch (type - 0x10000) {
	case 0:
		return 0x240;

	case 1:
		return 0x140;

	case 2:
		return 0x80;
	}

	printf("get_sig_len(): unhandled sig type %08x\n", type);
	return 0;
}

static u32 get_sub_len(u8 *sub)
{
	u32 type;

	type = be32(sub + 0x40);
	switch (type) {
	case 0:
		return 0x2c0;

	case 1:
		return 0x1c0;

	case 2:
		return 0x100;
	}

	printf("get_sub_len(): unhandled sub type %08x\n", type);
	return 0;
}

int check_ec(u8 *ng, u8 *ap, u8 *sig, u8 *sig_hash)
{
	u8 ap_hash[20];
	u8 *ng_Q, *ap_R, *ap_S;
	u8 *ap_Q, *sig_R, *sig_S;

	ng_Q = ng + 0x0108;
	ap_R = ap + 0x04;
	ap_S = ap + 0x22;

	SHA1(ap + 0x80, 0x100, ap_hash);

	ap_Q = ap + 0x0108;
	sig_R = sig;
	sig_S = sig + 30;

	return check_ecdsa(ng_Q, ap_R, ap_S, ap_hash)
	       && check_ecdsa(ap_Q, sig_R, sig_S, sig_hash);
}

static int check_rsa(u8 *h, u8 *sig, u8 *key, u32 n)
{
	u8 correct[0x200];
	u8 x[0x200];
	static const u8 ber[16] = "\x00\x30\x21\x30\x09\x06\x05\x2b"
	                          "\x0e\x03\x02\x1a\x05\x00\x04\x14";

//printf("n = %x\n", n);
//printf("key:\n");
//hexdump(key, n);
//printf("sig:\n");
//hexdump(sig, n);

	correct[0] = 0;
	correct[1] = 1;
	memset(correct + 2, 0xff, n - 38);
	memcpy(correct + n - 36, ber, 16);
	memcpy(correct + n - 20, h, 20);
//printf("correct is:\n");
//hexdump(correct, n);

	bn_exp(x, sig, key, n, key + n, 4);
//printf("x is:\n");
//hexdump(x, n);

	if (memcmp(correct, x, n) == 0)
		return 0;

	return -5;
}

static int check_hash(u8 *h, u8 *sig, u8 *key)
{
	u32 type;

	type = be32(sig) - 0x10000;
	if (type != be32(key + 0x40))
		return -6;

	switch (type) {
	case 1:
		return check_rsa(h, sig + 4, key + 0x88, 0x100);
	}

	return -7;
}

static u8 *find_cert_in_chain(u8 *sub, u8 *cert, u32 cert_len)
{
	char parent[64];
	char *child;
	u32 sig_len, sub_len;
	u8 *p;
	u8 *issuer;

	strncpy(parent, (char*)sub, sizeof parent);
	parent[sizeof parent - 1] = 0;
	child = strrchr(parent, '-');
	if (child)
		*child++ = 0;
	else {
		*parent = 0;
		child = (char*)sub;
	}

	for (p = cert; p < cert + cert_len; p += sig_len + sub_len) {
		sig_len = get_sig_len(p);
		if (sig_len == 0)
			return 0;
		issuer = p + sig_len;
		sub_len = get_sub_len(issuer);
		if (sub_len == 0)
			return 0;

		if (strcmp(parent, (char*)issuer) == 0
		    && strcmp(child, (char*)issuer + 0x44) == 0)
			return p;
	}

	return 0;
}

int check_cert_chain(u8 *data, u32 data_len, u8 *cert, u32 cert_len)
{
	u8 *sig;
	u8 *sub;
	u32 sig_len;
	u32 sub_len;
	u8 h[20];
	u8 *key_cert;
	u8 *key;
	int ret;
	sig = data;
	sig_len = get_sig_len(sig);
	if (sig_len == 0)
		return -1;
	sub = data + sig_len;
	sub_len = data_len - sig_len;
	if (sub_len == 0)
		return -2;

	for (;;) {
                printf(">>>>>> checking sig by %s...\n", sub);
                if (strcmp((char*)sub, "Root") == 0) {
			key = get_root_key();
			sha(sub, sub_len, h);
			if (be32(sig) != 0x10000)
				return -8;
			return check_rsa(h, sig + 4, key, 0x200);
		}

		key_cert = find_cert_in_chain(sub, cert, cert_len);
		if (key_cert == 0)
			return -3;

		key = key_cert + get_sig_len(key_cert);

		sha(sub, sub_len, h);
		ret = check_hash(h, sig, key);
		if (ret)
			return ret;

		sig = key_cert;
		sig_len = get_sig_len(sig);
		if (sig_len == 0)
			return -4;
		sub = sig + sig_len;
		sub_len = get_sub_len(sub);
		if (sub_len == 0)
			return -5;
	}
}

//
// compression
//

void do_yaz0(u8 *in, u32 in_size, u8 *out, u32 out_size)
{
	u32 nout;
	u8 bits;
	u32 nbits;
	u32 n, d, i;
        in_size++;
	bits = 0;
	nbits = 0;
	in += 0x10;
	for (nout = 0; nout < out_size; ) {
		if (nbits == 0) {
			bits = *in++;
			nbits = 8;
		}

		if ((bits & 0x80) != 0) {
			*out++ = *in++;
			nout++;
		} else {
			n = *in++;
			d = *in++;
			d |= (n << 8) & 0xf00;
			n >>= 4;
			if (n == 0)
				n = 0x10 + *in++;
			n += 2;
			d++;

			for (i = 0; i < n; i++) {
				*out = *(out - d);
				out++;
			}
			nout += n;
		}

		nbits--;
		bits <<= 1;
	};
}

//
// error handling
//

void fatal(const char *s, ...)
{
	char message[256];
	va_list ap;

	va_start(ap, s);
	vsnprintf(message, sizeof message, s, ap);

	perror(message);

	exit(1);
}

//
// output formatting
//

void print_bytes(u8 *x, u32 n)
{
	u32 i;

	for (i = 0; i < n; i++)
		printf("%02x", x[i]);
}

void hexdump(u8 *x, u32 n)
{
	u32 i, j;

	for (i = 0; i < n; i += 16) {
		printf("%04x:", i);
		for (j = 0; j < 16 && i + j < n; j++) {
			if ((j & 3) == 0)
				printf(" ");
			printf("%02x", *x++);
		}
		printf("\n");
	}
}

void dump_tmd(u8 *tmd)
{
	u32 i, n;
	u8 *p;

	printf("       issuer: %s\n", tmd + 0x140);
	printf("  sys_version: %016llx\n", be64(tmd + 0x0184));
	printf("     title_id: %016llx\n", be64(tmd + 0x018c));
	printf("   title_type: %08x\n", be32(tmd + 0x0194));
	printf("     group_id: %04x\n", be16(tmd + 0x0198));
	printf("title_version: %04x\n", be16(tmd + 0x01dc));
	printf(" num_contents: %04x\n", be16(tmd + 0x01de));
	printf("   boot_index: %04x\n", be16(tmd + 0x01e0));

	n = be16(tmd + 0x01de);
	p = tmd + 0x01e4;
	for (i = 0; i < n; i++) {
		printf("cid %08x  index %04x  type %04x  size %08llx\n",
		       be32(p), be16(p + 4), be16(p + 6), be64(p + 8));
		p += 0x24;
	}
}

double spinner_bs = 32 * 1024;

long long tv_2_ms(struct timeval *tv)
{
	return (long long)tv->tv_sec * 1000 + (long long)tv->tv_usec / 1000;
}

void spinner(u64 x, u64 max)
{
	const double MB = 1024. * 1024.;

	static long long start_ms;
	static long long update_ms;
	static double expected_total;
	static int updates;

	double d, delta;
	double percent;
	double copied, size;
	u32 h, m, s;
	struct timeval tv;
	long long ms;
	long dl;

	if (x == 0) {
		fflush(stderr); // mingw...
		//start_time = time(0);
		gettimeofday(&tv, NULL);
		start_ms = tv_2_ms(&tv);
		update_ms = start_ms;
		updates = 0;
		expected_total = 300;
	}

	//d = time(0) - start_time;
	gettimeofday(&tv, NULL);
	ms = tv_2_ms(&tv);
	delta = d = (double)(ms - start_ms) / 1000.;

	if (x && d != 0)
		expected_total = (3 * expected_total + d * max / x) / 4;

	if (expected_total > d)
		d = expected_total - d;
	else
		d = 1;
	if (x == max) d = 0;

	dl = lround(d);
	h = dl / 3600;
	m = (dl / 60) % 60;
	s = dl % 60;
	percent = 100.0 * x / max;
	copied = spinner_bs * (double)x;
	size = spinner_bs * (double)max;

	// 50ms = 1000/50 = 20 fps
	if (ms - update_ms >= 50 || x == 0 || x == max) {
		printf("%5.2f%% (%c) ETA: %d:%02d:%02d ",
				percent, "/|\\-"[updates % 4], h, m, s);
		printf("(%5.2fMB of %5.2fMB ~ %5.2fMB/s) time: %.2fs ",
				copied / MB, size / MB,
				copied / (delta?delta:1) / MB,
				delta);
		//printf("%d", (int)(ms - update_ms));
		printf("  \r");
		fflush(stdout);
		update_ms = ms;
		updates++;
	}
	if (x == max) {
		dl = lround(delta);
		h = dl / 3600;
		m = (dl / 60) % 60;
		s = dl % 60;
		printf("\nDone in  %d:%02d:%02d %60s\n", h, m, s, " ");
		fflush(stdout);
		return;
	}
}


```

`wbfs_file_2.9-master/source/tools.h`:

```h
// Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

#ifndef _TOOLS_H
#define _TOOLS_H

// basic data types
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;

u16 be16(const u8 *p);
u32 be32(const u8 *p);
u64 be64(const u8 *p);
u64 be34(const u8 *p);

void wbe16(u8 *p, u16 x);
void wbe32(u8 *p, u32 x);
void wbe64(u8 *p, u64 x);

//#define round_down(x,n) ((x) & -(n))
#define round_up(x,n) (-(-(x) & -(n)))

// bignum
int bn_compare(u8 *a, u8 *b, u32 n);
void bn_sub_modulus(u8 *a, u8 *N, u32 n);
void bn_add(u8 *d, u8 *a, u8 *b, u8 *N, u32 n);
void bn_mul(u8 *d, u8 *a, u8 *b, u8 *N, u32 n);
void bn_inv(u8 *d, u8 *a, u8 *N, u32 n);	// only for prime N
void bn_exp(u8 *d, u8 *a, u8 *N, u32 n, u8 *e, u32 en);

// crypto
void md5(u8 *data, u32 len, u8 *hash);
void sha(u8 *data, u32 len, u8 *hash);
void get_key(const char *name, u8 *key, u32 len);
void aes_cbc_dec(u8 *key, u8 *iv, u8 *in, u32 len, u8 *out);
void aes_cbc_enc(u8 *key, u8 *iv, u8 *in, u32 len, u8 *out);
void decrypt_title_key(u8 *tik, u8 *title_key);
int check_cert_chain(u8 *data, u32 data_len, u8 *cert, u32 cert_len);
int check_ec(u8 *ng, u8 *ap, u8 *sig, u8 *sig_hash);
void generate_ecdsa(u8 *R, u8 *S, u8 *k, u8 *hash);
int check_ecdsa(u8 *Q, u8 *R, u8 *S, u8 *hash);
void ec_priv_to_pub(u8 *k, u8 *Q);

// compression
void do_yaz0(u8 *in, u32 in_size, u8 *out, u32 out_size);

// error handling
void fatal(const char *s, ...);

// output formatting
void print_bytes(u8 *x, u32 n);
void hexdump(u8 *x, u32 n);
void dump_tmd(u8 *tmd);
void spinner(u64 x, u64 max);

#endif

```

`wbfs_file_2.9-master/source/wbfs.c`:

```c
// Copyright 2009 Kwiirk
// Licensed under the terms of the GNU GPL, version 2
// http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

// 10-2009 oggzee: additional commands, split file support

#ifdef WIN32
#include <windows.h>
#include <winioctl.h>
#include <io.h>
#define PATH_SEP_CHAR '\\'
#define PATH_SEP_STR  "\\"
#else
#define PATH_SEP_CHAR '/'
#define PATH_SEP_STR  "/"
#endif

#include <stdio.h>     /* for printf */
#include <stdlib.h>    /* for exit */
#include <getopt.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <libgen.h>

#include "tools.h"
#include "libwbfs.h"
#include "splits.h"

#include "platform.h"

char tool_version[] = "2.9";
char invalid_path[] = "/\\:|<>?*\"'";

wbfs_t *wbfs_try_open(char *disc,char *partition, int reset);
wbfs_t *wbfs_try_open_partition(char *fn,int reset);

#define GB (1024*1024*1024.)
#define DVD_SECT_SIZE 2048

int OPT_verbose = 1;
struct { char*opt; char *desc; } layout_desc[] =
{
    { "f0", "file:ID.ext" },
    { "f1", "file:ID_TITLE.ext" },
    { "f2", "file:TITLE [ID].ext" },
    { "d0", "dir:ID/ID.ext" },
    { "d1", "dir:ID_TITLE/ID.ext" },
    { "d2", "dir:TITLE [ID]/ID.ext" },
};
#define LAY_NUM 6
#define LAY_FILE_ID       0
#define LAY_FILE_ID_TITLE 1
#define LAY_FILE_TITLE_ID 2
#define LAY_DIR_ID        3
#define LAY_DIR_ID_TITLE  4
#define LAY_DIR_TITLE_ID  5
int OPT_layout = LAY_DIR_TITLE_ID;
int OPT_layout_spec = 0;
// copy all partitions
int OPT_part_all = 1;
int OPT_copy_1_1 = 0;
int OPT_overwrite = 0;
int OPT_trim = 0;
int OPT_scrub_size = 1; // 1 wii sector
int OPT_zero_sparse = 0;
int OPT_title_txt = 0;
int OPT_force = 0;
char *OPT_filename = 0; // first filename argument
char *OPT_arg3 = NULL;

static u32 _be32(const u8 *p)
{
    return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
}


#ifdef WIN32

#include <conio.h>

int con_readc(int *c)
{
    int ret;
    char ch;
    HANDLE fh = (HANDLE)_get_osfhandle(0);
    if (fh == INVALID_HANDLE_VALUE) {
        //print_error("_get_osfhandle");
        return 0;
    }
    int ftype = GetFileType(fh);
    //printf("ftype: %d\n", ftype);

    if (ftype == FILE_TYPE_CHAR) {
        // maybe: SetConsoleMode !ENABLE_LINE_INPUT
        // console
        ret = kbhit();
        //printf("kbhit: %d\n", ret);
        if (ret) {
            *c = getch();
            return 1;
        }

    } else if (ftype == FILE_TYPE_PIPE) {
        // process or cygwin terminal
        DWORD avail;
        ret = PeekNamedPipe(fh, NULL, 0, NULL, &avail, NULL);
        //printf("peek: %d, %d\n", ret, avail);
        if (ret && avail) {
read_char:
            ret = read(0, &ch, 1);
            if (ret == 1) {
                *c = ch;
                return 1;
            }
        }

    } else if (ftype == FILE_TYPE_DISK) {
        // file
        ret = WaitForSingleObject(fh, 0);
        //printf("wait: %d\n", ret);
        if (ret == 0) {
            goto read_char;
        }

    }
    // else unknown
    return 0;
}

#else

#include <sys/select.h>

int con_readc(int *c)
{
    int ret;
    char ch;
    fd_set fds;
    struct timeval tv = {0,0};
    //printf("isatty: %d\n", isatty(0));
    FD_ZERO(&fds);
    FD_SET(0, &fds); // stdin
    ret = select(1, &fds, NULL, NULL, &tv);
    if (ret == 1) {
        if (FD_ISSET(0, &fds)) {
            ret = read(0, &ch, 1);
            if (ret == 1) {
                *c = ch;
                return 1;
            }
        }
    }
    return 0;
}

#endif


int check_abort()
{
    static char cmd[16] = "";
    int c, len;
    while (con_readc(&c))
    {
        //printf("read: %d %d %x '%c' %s\n", ret, c, c, c, cmd);
        if (c == '\r' || c == '\n' || c == ' ') {
            // end of line or word
            if (strcasecmp(cmd, "abort") == 0) {
                *cmd = 0;
                return 1;
            }
            *cmd = 0;
        } else {
            // append
            len = strlen(cmd);
            if (len < (int)sizeof(cmd) - 1) {
                cmd[len] = c;
                cmd[len+1] = 0;
            }
        }
    }
    //Sleep(100);//debug

    return 0;
}

FILE *fopen_dev(const char *filename, const char *mode)
{
    char *name = get_dev_name((char*)filename);
    if (is_device(name)) {
        u32 sec_size = 0, sec_count = 0;
        get_capacity(name, &sec_size, &sec_count);
        off64_t size = (off64_t)sec_size * sec_count;
        static int first_time = 1;
        if (first_time) {
            printf("%s: "FMT_lld" (%d * %d)\n",
                    (sec_size == 2048) ? "DVD" : "DEV",
                    size, sec_size, sec_count);
            first_time = 0;
        }
    }
    return fopen(name, mode);
}

// offset is 4 bytes, count is bytes
int read_wii_file(void *_fp, u32 offset, u32 count, void *iobuf)
{
    FILE*fp =_fp;
    u64 off = offset;
    off <<= 2;
    size_t ret;
    if (fseeko(fp, off, SEEK_SET))
    {
        printf("error seeking disc %u\n", offset);
        return 1;
    }
    ret = fread(iobuf, count, 1, fp);
    if (ret != 1){
        //printf("ERROR: read (%u,%d) : %d\n", offset, count, ret);
        //printf("error reading disc %u "FMT_llu" %u = %u\n",
        //        offset, off, count, ret);
        //wbfs_error("error reading disc");
        static char tmpbuf[DVD_SECT_SIZE];
        u32 chunk;
        if (off % DVD_SECT_SIZE) {
            u64 noff = (off / DVD_SECT_SIZE) * DVD_SECT_SIZE;
            if (fseeko(fp, noff, SEEK_SET))
            {
                printf("ERROR seeking disc ("FMT_llu")\n", noff);
                return 1;
            }
            ret = fread(tmpbuf, DVD_SECT_SIZE, 1, fp);
            if (ret != 1){
                printf("ERROR: read ("FMT_llu", %d) : %d\n", noff, DVD_SECT_SIZE, (int)ret);
                return 1;
            }
            u32 delta = off - noff;
            u32 chunk = DVD_SECT_SIZE - delta;
            if (chunk > count) chunk = count;
            memcpy(iobuf, tmpbuf + delta, chunk);
            iobuf += chunk;
            count -= chunk;
            off   += chunk;
        }
        while (count) {
            if (fseeko(fp, off, SEEK_SET))
            {
                printf("ERROR seeking disc ("FMT_llu")\n", off);
                return 1;
            }
            ret = fread(tmpbuf, DVD_SECT_SIZE, 1, fp);
            if (ret != 1){
                printf("ERROR: read ("FMT_llu", %d) : %d\n", off, DVD_SECT_SIZE, (int)ret);
                return 1;
            }
            chunk = count;
            if (chunk > DVD_SECT_SIZE) chunk = DVD_SECT_SIZE;
            memcpy(iobuf, tmpbuf, chunk);
            iobuf += chunk;
            count -= chunk;
            off   += chunk;
        }
    }
    return 0;
}

// offset is 4 bytes, count is bytes
int write_wii_file(void *_fp, u32 offset, u32 count, void *iobuf)
{
    FILE*fp =_fp;
    u64 off = offset;
    off <<= 2;
    size_t ret;
    if (fseeko(fp, off, SEEK_SET))
    {
        printf("error seeking disc %u\n", offset);
        return 1;
    }
    ret = fwrite(iobuf, count, 1, fp);
    if (ret != 1){
        printf("write error (%u, %u)\n", offset, count);
        return 1;
    }
    return 0;
}

// offset and count is in 32k wii sector
int write_wii_sector_file(void *_fp, u32 lba, u32 count, void *iobuf)
{
    FILE*fp=_fp;
    u64 off = lba;
    off *=0x8000;
    //printf("w %u %u\n",lba,count);
    if (fseeko(fp, off, SEEK_SET))
    {
        printf("\n\n"FMT_lld" %p\n",off,_fp);
        wbfs_error("error seeking in written disc file");
        return 1;
    }
    if (fwrite(iobuf, count*0x8000, 1, fp) != 1){
        wbfs_error("error writing disc file");
        return 1;
    }
    return 0;
}


wbfs_t *wbfs_split_create_partition(split_info_t **sp, char *fn, int reset)
{
    wbfs_t *wbfs_p = NULL;
    split_info_t *s = NULL;
    u32 sector_size = 512;
    // max dual layer:
    u64 size = (u64)143432*2*0x8000ULL + 0x4000000;
    // +0x4000000 because freeblks size is n_wbfs_sec
    // and has to be aligned to 32 (num of bits in an int)
    // using exact file size as max dual layer is not enough for the worst case:
    // doing a 1:1 copy of a dual layer disc, because we need some space for the
    // headers. And the dual layer size is not wbfs sector aligned anyway.
    // So the minimum amount that has to be added is 32 wbfs sectors,
    // which is 32*2MB = 64MB = 0x4000000
    u32 n_sector = size / 512;
    int ret;
    //printf("OPEN_PART %s\n", fn);
    s = split_new();
    if (!s) return NULL;
    ret = split_create(s, fn, OPT_split_size, size);
    if (ret) return NULL;
    wbfs_p = wbfs_open_partition(
            split_read_sector, split_write_sector, s,
            sector_size, n_sector,0,reset);
    if (wbfs_p) {
        wbfs_p->close_hd = (close_callback_t)split_delete;
        if (sp) *sp = s;
    } else {
        split_delete(s);
    }
    return wbfs_p;
}

wbfs_t *wbfs_split_open_partition(split_info_t **sp, char *fn,int reset)
{
    wbfs_t *wbfs_p = NULL;
    split_info_t *s = NULL;
    u32 sector_size = 512;
    u32 n_sector;
    int ret;
    //printf("OPEN_PART %s\n", fn);
    s = split_new();
    if (!s) return NULL;
    ret = split_open(s, fn);
    n_sector = s->total_sec;
    if (ret) return NULL;
    wbfs_p = wbfs_open_partition(
            split_read_sector, split_write_sector, s,
            sector_size, n_sector,0,reset);
    if (wbfs_p) {
        wbfs_p->close_hd = (close_callback_t)split_delete;
        if (sp) *sp = s;
    } else {
        split_delete(s);
    }
    return wbfs_p;
}

wbfs_t *wbfs_auto_open_partition(char *fn,int reset)
{
    wbfs_t *p = NULL;
    if (is_device(fn)) {
        p = wbfs_try_open_partition(fn, reset);
    } else {
        p = wbfs_split_open_partition(NULL, fn, reset);
    }
    if (!p) {
        printf("Error opening WBFS '%s'\n", fn);
    }
    return p;
}

int get_first_disc_hdr(wbfs_t *p, u8 hdr[0x100])
{
    int count = wbfs_count_discs(p);
    if(count==0) {
        printf("wbfs empty\n");
        return -1;
    }
    u32 size;
    if(wbfs_get_disc_info(p,0,hdr,0x100,&size)) return -1;
    return 0;
}

int get_first_disc_id(wbfs_t *p, char *discid)
{
    u8 b[0x100];
    if (get_first_disc_hdr(p, b)) return -1;
    memcpy(discid, b, 6);
    discid[6] = 0;
    return 0;
}



int wbfs_applet_df(wbfs_t *p)
{
    u32 count = wbfs_count_usedblocks(p);
    printf("wbfs total: %.2fG used: %.2fG free: %.2fG\n",
            (float)p->n_wbfs_sec*p->wbfs_sec_sz/GB,
            (float)(p->n_wbfs_sec-count)*p->wbfs_sec_sz/GB,
            (float)(count)*p->wbfs_sec_sz/GB);
    /*printf("bytes tot:"FMT_lld" used:"FMT_lld"  free:"FMT_lld"\n",
      (u64)p->n_wbfs_sec*p->wbfs_sec_sz,
      (u64)(p->n_wbfs_sec-count)*p->wbfs_sec_sz,
      (u64)(count)*p->wbfs_sec_sz);*/
    return p ? 0 : -1;
}

int wbfs_applet_ls(wbfs_t *p)
{
    int count = wbfs_count_discs(p);
    if(count==0)
        printf("wbfs empty\n");
    else{
        int i;
        u32 size;
        u8 *b = wbfs_ioalloc(0x100);
        for (i=0;i<count;i++)
        {
            if(!wbfs_get_disc_info(p,i,b,0x100,&size))
                printf("%.6s : %-40s %.2fG\n", b, b + 0x20, size*4ULL/(GB));
            //printf("("FMT_lld")\n", (u64)size*4ULL);
        }
        wbfs_iofree(b);
    }   
    printf("\n");
    return wbfs_applet_df(p);
}

int wbfs_applet_mkhbc(wbfs_t *p)
{
    int count = wbfs_count_discs(p);
    char filename[7];
    FILE *xml;
    if(count==0)
        printf("wbfs empty\n");
    else{
        int i;
        u32 size;
        u8 *b = wbfs_ioalloc(0x100);
        for (i=0;i<count;i++)
        {
            wbfs_get_disc_info(p,i,b,0x100,&size);
            snprintf(filename,7,"%c%c%c%c%c%c",b[0], b[1], b[2], b[3], b[4], b[5]);
            mkdir(filename, 0777);
            printf("%s\n",filename);
            if (chdir(filename))
                wbfs_fatal("chdir");
            system("cp ../boot.dol .");
            system("cp ../icon.png .");
            xml = fopen("meta.xml","wb");
            fprintf(xml,"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n");
            fprintf(xml,"<app>\n\t<name>%s</name>\n", b+0x20);
            fprintf(xml,"<short_description>%.2fGB on USB HD </short_description>\n",size*4ULL/(GB));
            fprintf(xml,"<long_description>This launches the yal wbfs game loader by Kwiirk for discid %s</long_description>\n",filename);
            fprintf(xml,"</app>");
            fclose(xml);
            if (chdir(".."))
                wbfs_fatal("chdir");
        }
        wbfs_iofree(b);

    }   
    return p ? 0 : -1;
}
int wbfs_applet_init(wbfs_t *p)
{
    // nothing to do actually..
    // job already done by the reset flag of the wbfs_open_partition
    return p ? 0 : -1;

}

static void _spinner(int x,int y){ spinner(x,y);}

int wbfs_applet_addiso_gethdr(wbfs_t *p,char*argv, u8 *hdr)
{
    //printf("ADD\n");
    FILE *f = fopen_dev(argv, "rb");
    u8 discinfo[0x100];
    u8 discid[8];
    wbfs_disc_t *d;
    int ret;
    if(!f)
        wbfs_error("unable to open disc file");
    else
    {
        fread(discinfo, sizeof(discinfo), 1,f);
        if (hdr) memcpy(hdr, discinfo, sizeof(discinfo));
        memcpy(discid, discinfo, 6);
        discid[6] = 0;
        d = wbfs_open_disc(p,discid);
        fflush(stdout);
        if(d)
        {
            discinfo[6]=0;
            printf("%s already in disc..\n",discid);
            wbfs_close_disc(d);
            fclose(f);
            return 1;
        } else {
            int part = OPT_part_all ? ALL_PARTITIONS : ONLY_GAME_PARTITION;
            ret = wbfs_add_disc(p,read_wii_file,f,_spinner,part, OPT_copy_1_1);
            fclose(f);
            return ret;
        }
    }
    return 1;
}

int wbfs_applet_add_iso(wbfs_t *p,char*argv)
{
    return wbfs_applet_addiso_gethdr(p, argv, NULL);
}

int wbfs_applet_rm(wbfs_t *p,char*argv)
{
    return wbfs_rm_disc(p,(u8*)argv);
}

int do_extract(wbfs_disc_t *d, char *destname)
{
    int ret = 1;
    if(!d) return -1;
    FILE *f = fopen(destname,"rb");
    if (f) {
        fclose(f);
        if (OPT_overwrite) {
            printf("\nNote: file already exists: %s (overwriting)\n", destname);
        } else {
            printf("\nError: file already exists: %s\n", destname);
            return -1;
        }
    }

    f = fopen(destname,"wb");
    if(!f)
        wbfs_fatal("unable to open dest file");
    else{
        printf("writing to %s\n",destname);

        // check if the game is DVD9..
        u32 comp_blk;
        u32 last_blk;
        comp_blk = wbfs_sector_used2(d->p, d->header, &last_blk);
        u64 real_size = (u64)(last_blk+1) * (u64)d->p->wbfs_sec_sz;
        //u64 dual_size = (d->p->n_wii_sec_per_disc)*0x8000ULL;
        u64 single_size = (d->p->n_wii_sec_per_disc/2)*0x8000ULL;
        u64 size;
        //printf("allocating file\n");
        // write a zero at the end of the iso to ensure the correct size
        //fseeko(f,size-1ULL,SEEK_SET);
        //fwrite("",1,1,f);
        if (OPT_trim || real_size > single_size) {
            size = real_size;
        } else {
            size = single_size;
        }
        ret = file_truncate(fileno(f), size);
        if (ret) {
            printf("ERROR: TRUNCATE %s "FMT_lld"\n", destname, size);
            remove(destname);
            return -1;
        }

        ret = wbfs_extract_disc(d,write_wii_sector_file,f,_spinner);

        fflush(f);
        // sparse last block
        file_zero_data(fileno(f), real_size, size - real_size);
        fclose(f);
        printf("\n");
    }
    return ret;
}

void get_id_title(u8 *hdr, char *id, char *title, int re_space)
{
    int i, len;
    char *s;
    /* get ID */
    strncpy(id, (char*)hdr, 6);
    id[6] = 0;
    // trim leading space
    s = (char*)hdr+0x20;
    for (i=0; *s == ' ' && i<64; i++) s++;
    memset(title, 0, 65);
    strncpy(title, s, 64-i);
    title[64-i] = 0;
    len = strlen(title);
    // trim trailing space - not allowed on windows directories
    while (len && title[len-1] == ' ') {
        title[len-1] = 0;
        len--;
    }
    // replace silly chars with '_'
    for (i = 0; i < len; i++) {
        if(strchr(invalid_path, title[i]) || iscntrl(title[i])) {
            title[i] = '_';
        }
        if (re_space && title[i] == ' ') {
            title[i] = '_';
        }
    }
}

void layout_fmt(char *dest, char *id, char *title, int layout)
{
    *dest = 0;
    if (layout >= LAY_DIR_ID) layout -= LAY_DIR_ID;
    switch (layout) {
        case LAY_FILE_ID:
            sprintf(dest, "%s", id);
            break;
        case LAY_FILE_ID_TITLE:
            sprintf(dest, "%s_%s", id, title);
            break;
        case LAY_FILE_TITLE_ID:
            sprintf(dest, "%s [%s]", title, id);
            break;
    }
}

void get_game_id_title(char *buf, u8 *hdr, int re_space, int layout)
{
    char id[8];
    char title[65];
    get_id_title(hdr, id, title, re_space);
    layout_fmt(buf, id, title, layout);
}

void get_hdr_titlename(u8 *hdr, char *fname, char *path)
{
    int len;
    char *buf;
    // add path
    strcpy(fname, path);
    len = strlen(fname);
    if (len && fname[len-1] != '/' && fname[len-1] != '\\') {
        strcat(fname, PATH_SEP_STR);
    }
    len = strlen(fname);
    buf = fname + len;
    get_game_id_title(buf, hdr, 1, LAY_FILE_ID_TITLE);
}

int get_dest_name(char *dst_name, char *src_name, u8 *hdr, char *dest_arg, char *ext, int layout)
{
    char dest_dir[1024] = "";
    char id[8];
    char title[65];
    char *c;
    int ret;
    // get id and title
    get_id_title(hdr, id, title, 0);
    // is dest_arg a dir or file or none?
    if (dest_arg == NULL || *dest_arg == 0) {
        // no destination specified, use same as source
        strcpy(dest_dir, src_name);
        c = strrchr(dest_dir, '/');
        if (!c) c = strrchr(dest_dir, '\\');
        if (c) c++; else c = dest_dir;
        *c = 0;
    } else {
        c = strrchr(dest_arg, '.');
        if (c && strcasecmp(c, ext) == 0) {
            // dest filename specified
            strcpy(dst_name, dest_arg);
            return 0;
        }
        // dest_arg is dir
        strcpy(dest_dir, dest_arg);
        c = &dest_dir[strlen(dest_dir)-1];
        if (*c != '/' && *c != '\\') {
            strcat(c, PATH_SEP_STR);
        }
    }
    strcpy(dst_name, dest_dir);
    c = dst_name + strlen(dst_name);
    layout_fmt(c, id, title, layout);

    if (layout >= LAY_DIR_ID) {
        struct stat st;
        if (stat(dst_name, &st) != 0) {
            ret = mkdir(dst_name, 0777);
            if (ret != 0) {
                printf("error creating: %s\n", dst_name);
                perror("mkdir");
                return -1;
            }
        }
        strcat(c, PATH_SEP_STR);
        strcat(c, id);
    }
    strcat(c, ext);
    return 0;
}

void mk_title_txt(char *fname_wbfs, u8 *hdr)
{
    char fname[1024];
    char path[1024];
    char dname[1024];
    char id[8], title[64+1];
    FILE *f;

    if (OPT_title_txt == 0) return;

    // dirname() might modify, so we need a tmp copy
    strcpy(dname, fname_wbfs);
    strcpy(path, dirname(dname));
    get_hdr_titlename(hdr, fname, path);
    strcat(fname, ".txt");

    memcpy(id, hdr, 6);
    id[6] = 0;
    memcpy(title, hdr+0x20, 64);
    title[64] = 0;
    f = fopen(fname, "wb");
    if (!f) return;
    fprintf(f, "%.6s = %.64s\n", id, title);
    fclose(f);
    printf("Info file: %s\n", fname);
}

off64_t estimate_size(wbfs_t *p, read_wiidisc_callback_t read_disc, void *cb_data)
{
    off64_t size;
    u32 comp_sec, last_sec;
    int part = OPT_part_all ? ALL_PARTITIONS : ONLY_GAME_PARTITION;
    int ret;
    //u32 wbfs_size_disc(wbfs_t*p,read_wiidisc_callback_t read_src_wii_disc,
    //              void *callback_data,partition_selector_t sel,
    //              u32 *comp_size, u32 *real_size);
    ret = wbfs_size_disc(p, read_disc, cb_data, part, &comp_sec, &last_sec);
    if (ret) return -1;
    size = (off64_t)comp_sec * p->wii_sec_sz;
    // round up to wbfs sect size alignment
    size = (size + p->wbfs_sec_sz - 1) / p->wbfs_sec_sz * p->wbfs_sec_sz;
    // add 1 wbfs sect for header
    size += p->wbfs_sec_sz;
    return size;
}

int wbfs_applet_extract_iso(wbfs_t *p, char*discid, char *path)
{
    int ret = 1;
    wbfs_disc_t *d = wbfs_open_disc(p,(u8*)discid);
    if(d)
    {
        char isoname[1024];
        // if no layout specified use ID_TITLE naming
        // if (!OPT_layout_spec) OPT_layout = LAY_FILE_ID_TITLE;
        ret = get_dest_name(isoname, "", d->header->disc_header_copy, path, ".iso", OPT_layout);
        if (ret) {
            printf("ERROR: invalid dest path (%s)\n", path);
        } else {
            ret = do_extract(d, isoname);
        }
        wbfs_close_disc(d);
    }
    else
        printf("%s not in disc..\n",discid);
    return ret;
}

int wbfs_applet_extract_wbfs(wbfs_t *p, char*arg, char *path)
{
    int ret = 1;
    if (strlen(arg)!=6) {
        printf("invalid DISCID: '%s'\n", arg);
        return -1;
    }
    wbfs_disc_t *d = wbfs_open_disc(p,(u8*)arg);
    if(!d) {
        printf("%s not in disc..\n",arg);
        return -1;
    }

    u8 b[0x100];
    wbfs_disc_read(d, 0, b, 0x100);
    u32 magic = _be32(b+24);
    if(magic!=0x5D1C9EA3){
        printf("SKIP: Not a wii disc - bad magic (%08x)\n\n", magic);
        goto err;
    }

    char destname[1024];
    if (get_dest_name(destname, "", b, path, ".wbfs", OPT_layout)) {
        goto err;
    }

    printf("Writing '%s' to: '%s'\n", arg, destname);
    mk_title_txt(destname, b);
    fflush(stdout);

    split_info_t *dest_split;
    wbfs_t *dest_p = wbfs_split_create_partition(&dest_split, destname, 1);
    fflush(stdout);
    if (!dest_p) goto err;

    // estimate size
    off64_t size = estimate_size(dest_p, read_wiidisc_wbfsdisc_errcheck, d);
    // preallocate
    ret = split_truncate(dest_split, size);
    if (ret) {
        printf("Error pre-allocating!\n");
        return -1;
    }

    int part = OPT_part_all ? ALL_PARTITIONS : ONLY_GAME_PARTITION;
    ret = wbfs_add_disc(dest_p, read_wiidisc_wbfsdisc, d, _spinner, part, 0);
    fflush(stdout);

    wbfs_close_disc(d);
    wbfs_trim(dest_p);
    split_truncate(dest_split, dest_p->n_hd_sec*512ULL);
    wbfs_close(dest_p);
    fflush(stdout);

    return ret;

err:
    if (d) wbfs_close_disc(d);
    return -1;
}

int wbfs_applet_extract_wbfs_all(wbfs_t *p, char *path)
{
    // make sure path is not a file
    char *dot = strrchr(path, '.');
    if (dot && strcasecmp(dot, ".wbfs")==0) {
        printf("ERROR: specify DIR! (%s)\n", path);
        return -1;
    }
    int count = wbfs_count_discs(p);
    if(count==0) {
        printf("wbfs empty\n");
        return -1;
    }
    wbfs_applet_ls(p);
    printf("\nExtracting ALL games to: '%s'\n", path);

    int i, r, ret = 0;
    u32 size;
    u8 b[0x100];
    char discid[8];
    for (i=0;i<count;i++) {
        if(!wbfs_get_disc_info(p,i,b,0x100,&size)) {
            printf("\n%d / %d : ", i+1, count);
            printf("%.6s : %-40s %.2fG\n", b, b + 0x20, size*4ULL/(GB));
            //printf("("FMT_lld")\n", (u64)size*4ULL);
            // check magic
            u32 magic = _be32(b+24);
            if (magic != 0x5D1C9EA3){
                printf("SKIP: Not a wii disc - bad magic (%08x)\n\n", magic);
                continue;
            }
            memcpy(discid, b, 6);
            discid[6] = 0;
            r = wbfs_applet_extract_wbfs(p, discid, path);
            if (r) {
                printf("\nERROR: extract (%.6s) = %d\n\n", discid, r);
                ret = -1;
            }
        }
    }
    printf("Done.\n");
    return ret;
}

int wbfs_copy(wbfs_t *src_p, wbfs_t *dest_p, char *discid)
{
    wbfs_disc_t *d;
    // check if disc present on targer
    d = wbfs_open_disc(dest_p, (u8*)discid);
    fflush(stdout);
    if (d)
    {
        printf("%s already in disc..\n", discid);
        wbfs_close_disc(d);
        return -1;
    }

    // open disc in source
    d = wbfs_open_disc(src_p, (u8*)discid);
    if (!d)    {
        printf("Error: %s not found\n", discid);
        return -1;
    }

    fflush(stdout);
    int part = OPT_part_all ? ALL_PARTITIONS : ONLY_GAME_PARTITION;
    int ret = wbfs_add_disc(dest_p, read_wiidisc_wbfsdisc, d, _spinner, part, 0);
    fflush(stdout);

    wbfs_close_disc(d);
    fflush(stdout);

    return ret;
}

int wbfs_applet_add_wbfs(wbfs_t *p, char *fname)
{
    split_info_t *src_split;
    int ret;
    wbfs_t *src_p = wbfs_split_open_partition(&src_split, fname, 0);
    fflush(stdout);
    if (!src_p) return -1;

    char discid[8];
    if (get_first_disc_id(src_p, discid)) {
        printf("error finding ID in %s\n", fname);
        wbfs_close(src_p);
        return -1;
    }
    printf("Adding [%s] %s to WBFS\n", discid, fname);
    ret = wbfs_copy(src_p, p, discid);
    wbfs_close(src_p);

    return ret;
}

int wbfs_applet_wbfs_copy(wbfs_t *src_p, char *discid, char *dest_name)
{
    wbfs_t *dest_p;
    int ret;
    printf("WBFS COPY [%s] from %s to %s\n", discid, OPT_filename, dest_name);
    dest_p = wbfs_auto_open_partition(dest_name, 0);
    if (!src_p || !dest_p) {
        return -1;
    }
    ret = wbfs_copy(src_p, dest_p, discid);
    //wbfs_close(src_p);
    wbfs_close(dest_p);
    if (ret) {
        printf("COPY ERROR %d\n", ret);
    }
    return ret;
}

int wbfs_applet_make_info(wbfs_t *p)
{
    char *name_wbfs = OPT_filename;
    if (is_device(name_wbfs)) name_wbfs = "";
    int count = wbfs_count_discs(p);
    if(count==0)
        printf("wbfs empty\n");
    else{
        int i;
        u32 size;
        u8 *b = wbfs_ioalloc(0x100);
        for (i=0;i<count;i++)
        {
            if(!wbfs_get_disc_info(p,i,b,0x100,&size))
                printf("%.6s : %-40s %.2fG\n", b, b + 0x20, size*4ULL/(GB));
            //printf("("FMT_lld")\n", (u64)size*4ULL);
            mk_title_txt(name_wbfs, b);
        }
        wbfs_iofree(b);
    }   
    printf("\n");
    return wbfs_applet_df(p);
}

int wbfs_applet_id_title(wbfs_t *p)
{
    char id_title[100]; // required: 6+1+64+1
    u8 hdr[0x100];

    if (get_first_disc_hdr(p, hdr)) {
        return -1;
    }
    if (!OPT_layout_spec) OPT_layout = LAY_FILE_ID_TITLE;
    get_game_id_title(id_title, hdr, 0, OPT_layout);
    printf("%s\n", id_title);
    return 0;
}

int iso_id_title(char *filename)
{
    char id_title[100]; // required: 6+1+64+1
    u8 hdr[0x100];

    FILE *f = fopen_dev(filename, "rb");
    if (!f) {
        printf("ERROR: open(%s)\n", filename);
        return -1;
    }
    fread(hdr, sizeof(hdr), 1, f);
    fclose(f);

    if (!OPT_layout_spec) OPT_layout = LAY_FILE_ID_TITLE;
    get_game_id_title(id_title, hdr, 0, OPT_layout);
    printf("%s\n", id_title);
    return 0;
}

int wbfs_applet_extract_file(wbfs_t *p, char*argv, char *arg2)
{
    wbfs_disc_t *d;
    void *data = NULL;
    int size = 0;
    d = wbfs_open_disc(p,(u8*)argv);
    if(!d)
    {
        printf("Disc not found: %s\n", argv);
        return -1;
    }
    size = wbfs_extract_file(d, arg2, &data);
    wbfs_close_disc(d);
    if (!data || size <= 0) {
        printf("File: %s not found in disc %s\n",arg2, argv);
        return -1;
    }
    FILE *f;
    char *outfile = OPT_arg3;
    if (!outfile) outfile = arg2;
    if (!*outfile) outfile = "fst.dat";
    f = fopen(outfile, "wb");
    if (!f) {
        perror("fopen");
        return -1; 
    }
    if (fwrite(data, size, 1, f) != 1) {
        perror("write");
        return -1; 
    }
    fclose(f);
    printf("extracted: (%.6s) '%s' -> '%s'\n", argv, arg2, outfile);
    return 0;
}

typedef struct {
    u8 filetype;
    char name_offset[3];
    u32 fileoffset;
    u32 filelen;
} __attribute__((packed)) FST_ENTRY;


char *fstfilename2(FST_ENTRY *fst, u32 index)
{
    u32 count = _be32((u8*)&fst[0].filelen);
    u32 stringoffset;
    if (index < count)
    {
        //stringoffset = *(u32 *)&(fst[index]) % (256*256*256);
        stringoffset = _be32((u8*)&(fst[index])) % (256*256*256);
        return (char *)((u32)fst + count*12 + stringoffset);
    } else
    {
        return NULL;
    }
}

void fst_list(void *afst)
{
    //FST_ENTRY *fst = (FST_ENTRY *)*(u32 *)0x80000038;
    FST_ENTRY *fst = (FST_ENTRY *)afst;
    u32 count = _be32((u8*)&fst[0].filelen);
    u32 i;
    printf("fst files: %d\n", count);
    for (i=1;i<count;i++) {        
        //printf("%d %p %p\n", i, fst, fstfilename2(fst, i));
        printf("%d %s\n", i, fstfilename2(fst, i));
        fflush(stdout);
    }
}


int wbfs_applet_ls_file(wbfs_t *p,char*argv)
{
    wbfs_disc_t *d;
    int size = 0;
    void *fst;
    d = wbfs_open_disc(p,(u8*)argv);
    if (!d) {
        printf("%s not in disc..\n",argv);
        return -1;
    }
    size = wbfs_extract_file(d, "", &fst);
    wbfs_close_disc(d);
    if (!fst || size <= 0) {
        printf("%s not in disc..\n", argv);
        return -1;
    }
    printf("fst found: %d\n", size);
    fst_list(fst);
    free(fst);
    return 0;
}


int wbfs_applet_create(char *dest_name, char*argv)
{
    u8 hdr[0x100];
    split_info_t *sp = NULL;
    wbfs_t *p = wbfs_split_create_partition(&sp, dest_name, 1);
    int ret = -1;
    if (!p) return -1;

    // estimate size
    FILE *f = fopen_dev(argv, "rb");
    if(!f) {
        wbfs_error("unable to open disc file");
        return -1;
    }
    off64_t size = estimate_size(p, read_wii_file, f);
    fclose(f);
    // preallocate
    ret = split_truncate(sp, size);
    if (ret) {
        printf("Error pre-allocating!\n");
        return -1;
    }

    memset(hdr, 0, sizeof(hdr));
    ret = wbfs_applet_addiso_gethdr(p,argv, hdr);
    if (ret == 0 && hdr[0] != 0) {
        // success
        mk_title_txt(dest_name, hdr);
    }
    wbfs_trim(p);
    split_truncate(sp, p->n_hd_sec*512ULL);
    wbfs_close(p);
    return ret;
}


int conv_to_wbfs(char *filename, char *dest_dir)
{
    printf("Converting %s to .wbfs\n", filename);
    char newname[1024];
    u8 hdr[0x100];

    FILE *f = fopen_dev(filename,"rb");
    if(!f) {
        printf("unable to open iso file '%s'", filename);
        return -1;
    }
    fread(hdr, sizeof(hdr), 1,f);
    fclose(f);
    if (get_dest_name(newname, filename, hdr, dest_dir, ".wbfs", OPT_layout)) {
        return -1;
    }
    printf("Writing: %s\n", newname);
    wbfs_applet_create(newname, filename);
    return 0;
}

int conv_to_iso(char *filename, char *dest_dir)
{
    char discid[8];

    printf("Converting %s to ISO\n", filename);

    wbfs_t *p = wbfs_auto_open_partition(filename, 0);
    if(!p) {
        return -1;
    }
    if (get_first_disc_id(p, discid))
    {
        printf("error finding ID in %s\n", filename);
        return -1;
    }
    char path[1024], *c;
    if (*dest_dir == 0) {
        strcpy(path, filename);
        c = strrchr(path, '/');
        if (!c) c = strrchr(path, '\\');
        if (c) c++; else c = path;
        *c = 0;
        dest_dir = path;
    }
    wbfs_applet_extract_iso(p, discid, dest_dir);
    return 0;
}

int convert(char *filename, char *dest_dir)
{
    if (is_device(filename)) {
        if (conv_to_wbfs(filename, dest_dir)) return -1;
        return 0;
    }
    // only filename specified
    char *dot;
    dot = strrchr(filename, '.');
    if (!dot) return -2;
    if (strcasecmp(dot, ".iso") == 0) {
        if (conv_to_wbfs(filename, dest_dir)) return -1;
    } else if (strcasecmp(dot, ".wbfs") == 0) {
        if (conv_to_iso(filename, dest_dir)) return -1;
    } else {
        return -2;
    }
    return 0;
}

int get_iso_info(
        char *src,
        off64_t *p_size,
        off64_t *p_trim_size,
        u32 *p_num_blk,
        u32 *p_used_blk,
        u32 *p_trim_blk,
        FILE **pf,
        u8 *hdr,
        u8 *used
        )
{
    char *dot;
    int ret;
    int i;
    off64_t size = 0;
    off64_t trim_size = 0;
    u32 num_blk = 0;
    u32 used_blk = 0;
    u32 trim_blk = 0; // = last used + 1

    if (is_device(src)) {
        u32 sec_size = 0, sec_count = 0;
        get_capacity(src, &sec_size, &sec_count);
        if (sec_size != DVD_SECT_SIZE) {
            printf("ERROR: not a DVD\n");
            return -1;
        }
        size = (off64_t)sec_size * sec_count;
    } else {
        dot = strrchr(src, '.');
        if (!dot || strcasecmp(dot, ".iso") != 0) {
            printf("ERROR: Specify an .iso file! (%s)\n", src);
            return -1;
        }
    }
    FILE *f = fopen_dev(src, "rb");
    if(!f) {
        printf("unable to open iso file '%s'", src);
        return -1;
    }
    if (!is_device(src)) {
        ret = fseeko(f, 0, SEEK_END);
        if (ret == -1) {
            perror("fseeko");
            return -1;
        }
        size = ftello(f);
    }

    fseeko(f, 0, SEEK_SET);
    fread(hdr, 0x100, 1, f);
    // get usage table
    wiidisc_t *d = 0;
    if (!OPT_copy_1_1) {
        memset(used, 0, WII_MAX_SECTORS);
        d = wd_open_disc(read_wii_file, f);
        if (!d) {
            printf("unable to open wii disc");
            return -1;
        }
        int part = OPT_part_all ? ALL_PARTITIONS : ONLY_GAME_PARTITION;
        wd_build_disc_usage(d, part, used);
        wd_close_disc(d);
        d = 0;
    }
    // debug: dump usage table
    /*
       for (i=0; i<WII_MAX_SECTORS; i++) {
       if ( (i%64) == 0 ) {
       printf("\n%05x : ", i);
       }
       printf("%d", block_used(used,i,1));
       }
       printf("\n");
       exit(0);
       */
    // calculate sizes
    num_blk = (size + WII_SECTOR_SIZE - 1) / WII_SECTOR_SIZE;
    if (size % WII_SECTOR_SIZE) {
        printf("WARNING: size not wii sector aligned!\n");
    }
    if (OPT_copy_1_1) {
        trim_size = size;
        used_blk = num_blk;
        trim_blk = num_blk;
    } else {
        for (i=0; i<WII_MAX_SECTORS; i++) {
            if (used[i]) {
                trim_blk = i + 1;
                used_blk++;
            }
        }
        if (num_blk < trim_blk) {
            printf("ERROR: invalid block count: %d < %d\n", num_blk, trim_blk);
            return -1;
        }
        if (OPT_trim) {
            trim_size = (off64_t)trim_blk * WII_SECTOR_SIZE;
        } else {
            trim_size = size;
        }
    }
    *p_size      = size;
    *p_trim_size = trim_size;
    *p_num_blk   = num_blk;
    *p_used_blk  = used_blk;
    *p_trim_blk  = trim_blk;
    *pf          = f;
    return 0;
}


int scrub(char *src, char *dest)
{
    char destname[1024];
    u8 hdr[0x100];
    int ret;
    int i, j;
    off64_t size = 0;
    off64_t trim_size = 0;
    u32 num_blk = 0;
    u32 used_blk = 0;
    u32 trim_blk = 0; // = last used + 1
    FILE *f = NULL;
    u8 *used = 0;

    printf("Scrubbing %s\n", src);

    used = calloc(1, WII_MAX_SECTORS);
    if (!used) {
        printf("unable to alloc memory");
        return -1;
    }

    ret = get_iso_info(src,
            &size,
            &trim_size,
            &num_blk,
            &used_blk,
            &trim_blk,
            &f,
            hdr,
            used);
    if (ret) return -1;	

    // create dest file
    if (get_dest_name(destname, src, hdr, dest, ".iso", OPT_layout)) {
        return -1;
    }
    printf("Writing %s\n", destname);
    struct stat st;
    if (stat(destname, &st) == 0) {
        if (OPT_overwrite) {
            printf("\nNote: file already exists: %s (overwriting)\n", destname);
        } else {
            printf("ERROR: already exists: %s\n", destname);
            return -1;
        }
    }
    FILE *f_dest = fopen(destname, "wb");
    if(!f_dest) {
        printf("unable to open iso file '%s'", destname);
        return -1;
    }
    ret = file_truncate(fileno(f_dest), trim_size);
    if (ret) {
        printf("ERROR: TRUNCATE %s "FMT_lld"\n", destname, trim_size);
        goto error;
    }
    // copy
    u32 blk, off, blk_size;
    u32 cnt_blk; // for spinner
    u32 write_blk = 0;
    off64_t offset;
    off64_t sparse_off = 0, sparse_len = 0;
    void *zbuf = calloc(1, WII_SECTOR_SIZE);
    void *buf = malloc(WII_SECTOR_SIZE);

    if (!buf) {
        printf("unable to alloc memory");
        goto error;
    }
    cnt_blk = 0;
    spinner(0, used_blk);
    for (i=0; i<(int)(num_blk+OPT_scrub_size-1)/OPT_scrub_size; i++) {
        if (!OPT_copy_1_1) {
            if (!block_used(used, i, OPT_scrub_size)) {
                if (sparse_len == 0) {
                    sparse_off = (off64_t)i * OPT_scrub_size * WII_SECTOR_SIZE;
                }
                sparse_len += (off64_t)OPT_scrub_size * WII_SECTOR_SIZE;
                continue;
            }
        }
        for (j=0; j<OPT_scrub_size; j++) {
            blk = i * OPT_scrub_size + j;
            if (blk >= num_blk) break;
            off = blk * (WII_SECTOR_SIZE >> 2);
            offset = (off64_t)blk * WII_SECTOR_SIZE;
            if (offset >= size) break;
            if (size - offset < WII_SECTOR_SIZE) {
                blk_size = size - offset;
            } else {
                blk_size = WII_SECTOR_SIZE;
            }
            spinner(cnt_blk, used_blk);
            cnt_blk++;
            ret = read_wii_file(f, off, blk_size, buf);
            if (ret) {
                printf("ERROR: read!\n");
                goto error;
            }
            if (OPT_zero_sparse) {
                // skip writing zero filled blocks
                if (memcmp(buf, zbuf, blk_size) == 0) {
                    if (sparse_len == 0) {
                        sparse_off = offset;
                    }
                    sparse_len += blk_size;
                    continue;
                }
            }
            if (sparse_len) {
                fflush(f_dest);
                file_zero_data(fileno(f_dest), sparse_off, sparse_len);
                sparse_off = sparse_len = 0;
            }
            ret = write_wii_file(f_dest, off, blk_size, buf);
            if (ret) {
                printf("ERROR: write!\n");
                goto error;
            }
            write_blk++;
        }
    }
    spinner(used_blk, used_blk);
    //printf("Blocks written: %d bytes: "FMT_lld"\n",
    //        write_blk, (off64_t)write_blk * WII_SECTOR_SIZE);

    if (sparse_len) {
        //printf("Trailing sparse block: "FMT_lld" "FMT_lld"\n", sparse_off, sparse_len);
        fflush(f_dest);
        file_zero_data(fileno(f_dest), sparse_off, sparse_len);
        sparse_off = sparse_len = 0;
    }

    fclose(f_dest);
    fclose(f);
    return 0;

error:
    if (f) fclose(f);
    if (f_dest) fclose(f_dest);
    remove(destname);
    return -1;
}

int iso_info(char *src)
{
    u8 hdr[0x100];
    int ret;
    off64_t size = 0;
    off64_t trim_size;
    u32 num_blk = 0;
    u32 used_blk = 0;
    u32 trim_blk = 0; // = last used + 1
    FILE *f = NULL;
    u8 *used = 0;

    printf("ISO INFO %s\n", src);

    used = calloc(1, WII_MAX_SECTORS);
    if (!used) {
        printf("unable to alloc memory");
        return -1;
    }

    ret = get_iso_info(src,
            &size,
            &trim_size,
            &num_blk,
            &used_blk,
            &trim_blk,
            &f,
            hdr,
            used);
    if (ret) return -1;	

    printf("id:         %.6s\n", hdr);
    printf("title:      '%.64s'\n", hdr+0x20);
    printf("size:       "FMT_lld"\n", size);
    printf("trim size:  "FMT_lld"\n", (u64)trim_blk * WII_SECTOR_SIZE);
    printf("trim sect:  %u\n",        trim_blk);
    printf("trim gb:    %.2f\n", (float)trim_blk * WII_SECTOR_SIZE / GB);
    printf("scrub size: "FMT_lld"\n", (u64)used_blk * WII_SECTOR_SIZE);
    printf("scrub sect: %u\n",       used_blk);
    printf("scrub gb:   %.2f\n", (float)used_blk * WII_SECTOR_SIZE / GB);
    fclose(f);
    return 0;
}


int wbfs_applet_debug_info(wbfs_t *p)
{
#define PRINT_X(X) printf("%-20s: %-7d 0x%x\n", #X, (u32)p->X, (u32)p->X)
    //wbfs_head_t *head;
    //PRINT_X(head->magic);
    // parameters copied in the partition for easy dumping, and bug reports
    PRINT_X(head->n_hd_sec);           // total number of hd_sec in this partition
    PRINT_X(head->hd_sec_sz_s);       // sector size in this partition
    PRINT_X(head->wbfs_sec_sz_s);     // size of a wbfs sec

    /* hdsectors, the size of the sector provided by the hosting hard drive */
    PRINT_X(hd_sec_sz);
    PRINT_X(hd_sec_sz_s); // the power of two of the last number
    PRINT_X(n_hd_sec);     // the number of hd sector in the wbfs partition

    /* standard wii sector (0x8000 bytes) */
    PRINT_X(wii_sec_sz); 
    PRINT_X(wii_sec_sz_s);
    PRINT_X(n_wii_sec);
    PRINT_X(n_wii_sec_per_disc);

    /* The size of a wbfs sector */
    PRINT_X(wbfs_sec_sz);
    PRINT_X(wbfs_sec_sz_s); 
    PRINT_X(n_wbfs_sec);   // this must fit in 16 bit!
    PRINT_X(n_wbfs_sec_per_disc);   // size of the lookup table

    PRINT_X(part_lba);
    PRINT_X(max_disc);
    PRINT_X(freeblks_lba);
    //u32 *freeblks;
    PRINT_X(disc_info_sz);

    PRINT_X(n_disc_open);
    return 0;
}


struct wbfs_applets{
    char *opt;
    int (*func)(wbfs_t *p);
    int (*func_arg)(wbfs_t *p, char *argv);
    int (*func_arg2)(wbfs_t *p, char *arg1, char *arg2);
    char *arg_name;
    int dest; // is first arg a src or dest
} wbfs_applets[] = {
#define APPLET_0(d,x)   { #x,wbfs_applet_##x,NULL,NULL, "", d}
#define APPLET_1(d,x,A) { #x,NULL,wbfs_applet_##x,NULL, A, d}
#define APPLET_2(d,x,A) { #x,NULL,NULL,wbfs_applet_##x, A, d}
    APPLET_0(0, ls),
    APPLET_0(0, df),
    APPLET_0(0, make_info),
    APPLET_0(0, id_title),
    APPLET_0(1, init),
    APPLET_1(1, add_iso,          "<SRC:drive or file.iso>"),
    APPLET_1(1, add_wbfs,         "<SRC:filename.wbfs>"),
    APPLET_1(1, rm,               "<GAMEID>"),
    APPLET_2(0, extract_iso,      "<GAMEID> <DST:dir or file.iso>"),
    APPLET_2(0, extract_wbfs,     "<GAMEID> <DST:dir or file.wbfs>"),
    APPLET_1(0, extract_wbfs_all, "<DST:dir>"),
    APPLET_2(0, wbfs_copy,        "<GAMEID> <DST:drive or file.wbfs>"),
    APPLET_1(0, ls_file,          "<GAMEID>"),
    APPLET_2(0, extract_file,     "<GAMEID> <file> [<DST:file>]"),
    //APPLET_0(0, mkhbc),
    APPLET_0(0, debug_info),
};
static int num_applets = sizeof(wbfs_applets)/sizeof(wbfs_applets[0]);

void usage_basic(char **argv)
{
    char *tool = strrchr(argv[0], '/');
    if (!tool) tool = strrchr(argv[0], '\\');
    if (tool) tool++; else tool = argv[0];
    //printf("Usage: %s [-d disk|-p partition]\n", argv[0]);
    printf("%s %s by oggzee, based on wbfs by kwiirk\n\n", tool, tool_version);
    printf("Usage: %s [OPTIONS] <DRIVE or FILENAME> [COMMAND [ARGS]]:\n", tool);
    printf("\n");
    printf("  Given just a filename it will convert from iso to wbfs or vice versa:\n");
    printf("\n");
    printf("    %s filename.iso\n", tool);
    printf("    Will convert filename.iso to GAMEID.wbfs\n");
    printf("    And create an info file GAMEID_TITLE.txt\n");
    printf("\n");
    printf("    %s filename.wbfs\n", tool);
    printf("    Will convert filename.wbfs to GAMEID_TITLE.iso\n");
    printf("\n");
}

void usage(char **argv)
{
    int i;
    usage_basic(argv);
    printf("  COMMANDS:\n");
    printf("    <drive or file.iso>  convert  <DST:dir or file.wbfs>\n");
    printf("        <filename.wbfs>  convert  <DST:dir or file.iso>\n");
    printf("    <drive or file.iso>  scrub    <DST:dir or file.iso>\n");
    printf("    <DST:filename.wbfs>  create   <SRC:drive or file.iso>\n");
    for (i=0;i<num_applets;i++) {
        printf("    %sdrive or file>  %-16s %s\n",
                wbfs_applets[i].dest ? "<DST:" : "    <",
                wbfs_applets[i].opt,
                wbfs_applets[i].arg_name);
    }
    printf("        <drive or file>  iso_info\n");
    printf("\n");
    printf("  OPTIONS: (it's recommended to just use the defaults)\n");
    printf("    -s SIZE  :  Set split size ["FMT_lld"] ", DEF_SPLIT_SIZE);
    printf("(%d sectors)\n", (u32)(DEF_SPLIT_SIZE/512));
    printf("                Must be a multiple of 512 (sector size)\n");
    printf("    -2       :  Use split size: 2GB-32kb ("FMT_lld")\n", SPLIT_SIZE_2);
    printf("    -4       :  Use split size: 4GB-32kb ("FMT_lld")\n", SPLIT_SIZE_4);
    printf("    -0       :  Don't split (split size: "FMT_lld")\n", SPLIT_SIZE_0);
    printf("    -u SIZE  :  Set scrub block size [32768] (1 wii sector)\n");
    printf("                Must be a multiple of 32768 (wii sector size)\n");
    printf("                Special values: 1=1 wii sector, 2=2mb (.wbfs block)\n");
    printf("    -z       :  make zero filled blocks as sparse when scrubbing\n");
    printf("    -a       :  Copy ALL partitions from ISO [default]\n");
    printf("    -g       :  Copy only game partition from ISO\n");
    printf("    -1       :  Copy 1:1 from ISO\n");
    printf("    -f       :  Force wbfs mode even if the wbfs file or partition\n");
    printf("                integrity check is invalid (non matching number of\n");
    printf("                sectors or other parameters)\n");
    printf("    -t       :  trim extracted iso size\n");
    printf("    -x 0|1   :  disable|enable .txt file creation [default:0]\n");
    printf("    -l X     :  Layout of the destination filename:\n");
    printf("                -l f0 = file: ID.ext             (same as -b)\n");
    printf("                -l f1 = file: ID_TITLE.ext\n");
    printf("                -l f2 = file: TITLE [ID].ext\n");
    printf("                -l d0 = dir:  ID/ID.ext\n");
    printf("                -l d1 = dir:  ID_TITLE/ID.ext    (same as -d)\n");
    printf("                -l d2 = dir:  TITLE [ID]/ID.ext  [default]\n");
    printf("    -b       :  Same as -l f0\n");
    printf("    -d       :  Same as -l d1\n");
    //printf("    -w       :  Overwrite\n");
    printf("    -h       :  Help\n");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
    int opt;
    int i;
    int ret = -1;
    //char *partition=0,*disc =0;
    char *filename = 0;
    char *dest_name = "";

    // disable stdout buffering
    setvbuf(stdout, NULL, _IONBF, 0); 
    setvbuf(stdin, NULL, _IONBF, 0); 

    if (argc == 1) {
        usage_basic(argv);
        printf("  Use -h for help on commands and options\n");
        exit(EXIT_FAILURE);
    }
    for (i=1; i<argc;i++) {
        if (strcmp(argv[i], "id_title") == 0) {
            OPT_verbose = 0;
        }
    }

    while ((opt = getopt(argc, argv, "s:u:x:l:hag0124dbftwz")) != -1) {
        switch (opt) {
            /*case 'p':
              partition = optarg;
              break;
              case 'd':
              disc = optarg;
              break;*/
            case 's':
                {
                    long long size;
                    if (sscanf(optarg, ""FMT_lld"", &size) != 1) {
                        printf("Invalid split size value!\n");
                        goto err;
                    }
                    if (size <= 0 || size % 512) {
                        printf("Invalid split size!\n");
                        goto err;
                    }
                    if (size % (32*1024)) {
                        printf("WARNING: split size not 32kb aligned!\n");
                    }
                    OPT_split_size = size;
                    printf("Split size: "FMT_lld" (%d sectors)\n",
                            OPT_split_size, (u32)(OPT_split_size/512));
                }
                break;
            case 'u':
                {
                    int size;
                    if (sscanf(optarg, "%d", &size) != 1) {
                        printf("Invalid scrub size value!\n");
                        goto err;
                    }
                    if (size == 1) {
                        // 32k
                        OPT_scrub_size = 1;
                    } else if (size == 2) {
                        // 2MB
                        OPT_scrub_size = (2*1024*1024) / WII_SECTOR_SIZE;
                    } else if (size <= 0 || size % WII_SECTOR_SIZE) {
                        printf("Invalid scrub size! (%d)\n", size);
                        goto err;
                    } else {
                        OPT_scrub_size = size / WII_SECTOR_SIZE;
                    }
                    printf("Scrub block size: %d (%d wii sectors)\n",
                            OPT_scrub_size * WII_SECTOR_SIZE, OPT_scrub_size);
                }
                break;
            case 'x':
                {
                    int n;
                    if (sscanf(optarg, "%d", &n) != 1) {
                        printf("Invalid -x value! (%s)\n", optarg);
                        goto err;
                    }
                    if (n != 0 && n != 1) {
                        printf("Invalid -x value! (%s)\n", optarg);
                        goto err;
                    }
                    OPT_title_txt = n;
                    printf("Using OPTION: -x : %s id_title.txt creation\n",
                            OPT_title_txt ? "enable" : "disable");
                }
                break;
            case 'l':
                {
                    int i;
                    for (i=0; i<LAY_NUM; i++) {
                        if (strcmp(optarg, layout_desc[i].opt) == 0) {
                            break;
                        }
                    }
                    if (i >= LAY_NUM) {
                        printf("Invalid -l value! (%s)\n", optarg);
                        goto err;
                    }
                    OPT_layout = i;
                    OPT_layout_spec = 1;
                    if (OPT_verbose) {
                        printf("Using OPTION: -l : %s (%s)\n", optarg, layout_desc[i].desc);
                    }
                }
                break;
            case 'd':
                printf("Using OPTION -d : Create a GAMEID_TITLE directory\n");
                OPT_layout = LAY_DIR_ID_TITLE;
                OPT_layout_spec = 1;
                break;
            case 'b':
                printf("Using OPTION -b : Create files in base directory\n");
                OPT_layout = LAY_FILE_ID;
                OPT_layout_spec = 1;
                break;
            case 'a':
                printf("Using OPTION -a : install all partitions\n");
                OPT_part_all = 1;
                break;
            case 'g':
                printf("Using OPTION -g : install only game partitions\n");
                OPT_part_all = 0;
                break;
            case '1':
                printf("Using OPTION -1 : make a 1:1 copy\n");
                OPT_copy_1_1 = 1;
                OPT_part_all = 1;
                break;
            case '0':
                OPT_split_size = SPLIT_SIZE_0;
                printf("Using OPTION -0 : no splits.\n");
                printf("Split size: "FMT_lld" (%d sectors)\n",
                        OPT_split_size, (u32)(OPT_split_size/512));
                break;
            case '2':
                OPT_split_size = SPLIT_SIZE_2;
                printf("Using OPTION -2 : ");
                printf("Split size: "FMT_lld" (%d sectors)\n",
                        OPT_split_size, (u32)(OPT_split_size/512));
                break;
            case '4':
                OPT_split_size = SPLIT_SIZE_4;
                printf("Using OPTION -4 : ");
                printf("Split size: "FMT_lld" (%d sectors)\n",
                        OPT_split_size, (u32)(OPT_split_size/512));
                break;
            case 'f':
                printf("Using OPTION -f : force wbfs even if wbfs integrity is invalid\n");
                wbfs_set_force_mode(1);
                OPT_force = 1;
                break;
            case 't':
                printf("Using OPTION -t : trim extracted iso size\n");
                OPT_trim = 1;
                break;
            case 'w':
                printf("Using OPTION -w : overwrite target iso\n");
                OPT_overwrite = 1;
                break;
            case 'z':
                printf("Using OPTION -z : sparse zero filled blocks\n");
                OPT_zero_sparse = 1;
                break;
            case 'h':
            default: /* '?' */
                usage(argv);
        }
    }
    if (optind >= argc) {
        usage(argv);
        exit(EXIT_FAILURE);
    }

    OPT_filename = filename = argv[optind];
    optind++;

    if (optind == argc)
    {
        // only filename specified
        dest_name = "";
        goto L_convert;
    }

    if (optind >= argc) {
        goto usage;
    }


    if (strcmp(argv[optind], "create")==0)
    {
        if(optind + 1 >= argc) goto usage;
        dest_name = argv[optind+1];
        return wbfs_applet_create(filename, dest_name);
    }

    if (strcmp(argv[optind], "convert")==0)
    {
        if(optind + 1 >= argc) goto usage;
        dest_name = argv[optind+1];
L_convert:
        ret = convert(filename, dest_name);
        if (ret == -2) goto usage;
        if (ret == -1) goto err;
        goto exit;
    }

    if (strcmp(argv[optind], "scrub")==0)
    {
        if(optind + 1 >= argc) goto usage;
        dest_name = argv[optind+1];
        ret = scrub(filename, dest_name);
        if (ret) goto err;
        goto exit;
    }

    if (strcmp(argv[optind], "id_title")==0)
    {
        char *p;
        p = strrchr(filename, '.');
        if (p && (strcasecmp(p, ".iso") == 0)) {
            ret = iso_id_title(filename);
            if (ret) goto err;
            goto exit;
        }
    }

    if (strcmp(argv[optind], "init")==0)
    {
        if (!OPT_force) {
            printf("init disabled, use -f to force wbfs formatting!\n");
            goto err;
        }
    }

    if (strcmp(argv[optind], "iso_info")==0)
    {
        ret = iso_info(filename);
        if (ret) goto err;
        goto exit;
    }

    for (i=0;i<num_applets;i++)
    {
        struct wbfs_applets *ap = &wbfs_applets[i];
        if (strcmp(argv[optind],ap->opt)==0)
        {
            //wbfs_t *p = wbfs_try_open_partition(filename,
            //                          ap->func== wbfs_applet_init);
            wbfs_t *p = wbfs_auto_open_partition(filename,
                    ap->func== wbfs_applet_init);
            if(!p) {
                return 1;
            }
            if(ap->func)
            {
                ret = ap->func(p);
            }
            else if(ap->func_arg)
            {
                if(optind + 1 >= argc)
                    usage(argv);
                else
                    ret = ap->func_arg(p, argv[optind+1]);
            }
            else if(ap->func_arg2)
            {
                if(optind + 2 >= argc)
                    usage(argv);
                else {
                    if (optind + 3 < argc)
                        OPT_arg3 = argv[optind+3];
                    else
                        OPT_arg3 = NULL;
                    ret = ap->func_arg2(p, argv[optind+1], argv[optind+2]);
                }
            }
            wbfs_close(p);
            break;
        }
    }
    if (i==num_applets) {
        printf("Error: unknown command: %s\n\n", argv[optind]);
        goto usage;
    }
    if (ret) goto err;

exit:
    exit(EXIT_SUCCESS);
usage:
    usage(argv);
err:
    exit(EXIT_FAILURE);
}


```
